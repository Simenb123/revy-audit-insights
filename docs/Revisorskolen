Revisorskolen ‚Äì Dypanalyse og Implementeringsplan
1) üîé Repo-unders√∏kelse
Kodebase og struktur: Prosjektet er en React 18 applikasjon med TypeScript, bygget med Vite. UI-stacken inkluderer Tailwind CSS med shadcn/ui komponentbiblioteket (Radix UI), TanStack React Query for datah√•ndtering og React Router v6 for navigasjon[1][2]. Koden er strukturert i mapper som src/pages (rutesider), src/components (gjenbrukbare komponenter), src/hooks (React Query hooks), og Supabase Edge Functions i supabase/functions. All UI-tekst er p√• norsk, og komponentstil bruker semantiske Tailwind-klasser (f.eks. text-muted-foreground, bg-background) fremfor hardkodede farger[3].
Routing og navigasjon: Hovedruter defineres i src/App.tsx inni en <Routes>-blokk[4]. Venstremenyen (ResizableLeftSidebar) samler navigasjonslenker i konstanter som resourceItems[5]. Her ser vi f.eks. ‚ÄúRevisjons Akademiet‚Äù med url /academy og ‚ÄúL√¶ring‚Äù med url /training som egne moduler i menyen[5]. Den nye modulen Revisorskolen vil analogt legges til her med tittel "Revisorskolen" og url /revisorskolen. For √• sikre at kun testbrukere ser den, kan vi legge til en roles: ['testbruker'] p√• menu-item (som det gj√∏res for admin-seksjoner i adminItems[6]). I routerkonfigurasjonen skal vi definere en ny Route: <Route path="revisorskolen" element={<ProtectedRoute><Revisorskolen /></ProtectedRoute>} />, tilsvarende hvordan /academy og /training er satt opp[7]. Dette vil s√∏rge for at komponenten pages/Revisorskolen.tsx rendres n√•r brukeren navigerer til /revisorskolen.
Eksisterende m√∏nstre: - Supabase klient: Applikasjonen oppretter en enkelt Supabase-klient i src/supabaseClients.ts med createClient[8]. Denne benyttes i hooks (f.eks. useTrainingProgress) for databasekall med RLS-beskyttelse ved at brukerens JWT benyttes automatisk[9]. - React Query hooks: Hvert data-domene har egne hooks. For eksempel henter useTrainingProgress inn logged-in bruker via supabase.auth.getUser() og deretter .from('training_progress').select(*)...[9]. Egne hooks oppdaterer ogs√• data med useMutation og invalidation. Vi f√∏lger samme struktur for Revisorskolen (f.eks. useRun, useStartRun), inkl. caching via queryKey. - shadcn/ui og styling: UI-komponenter som <Card>, <Button> og <Badge> brukes flittig for konsistent styling[10][11]. Man benytter Radix UI sine primitive komponenter (f.eks. <Tabs>, <Progress>) sammen med Tailwind utility-klasser for layout. Typisk layout for sider er √• bruke en standard side-wrapper (som StandardPageLayout eller <PageLayout>) og deretter bygge innhold med kort, faner osv. Vi gjenskaper dette i Revisorskolen. - Toasts og feilh√•ndtering: Applikasjonen har et toast-system (basert p√• Radix Toast). Toaster er inkludert i App.tsx for global visning[12]. Hooks bruker useToast() for √• vise suksess- og feilmeldinger[13]. For eksempel, useUpdateTrainingProgress viser toast ‚ÄúProgresjon oppdatert!‚Äù p√• suksess[14]. Vi f√∏lger samme praksis: etter viktige handlinger som √• starte spill eller utf√∏re handling, vises en toast ved feil (f.eks. ‚ÄúKunne ikke utf√∏re handlingen‚Äù). - Error boundaries: Repoet har sannsynligvis en global error boundary/h√•ndtering (f.eks. i ProtectedRoute for auth). Vi s√∏rger for √• h√•ndtere feil lokalt i komponenter (f.eks. vise feilmelding i UI hvis noe feiler √• laste), og lar eventuelle uventede exceptions boble opp til global feilh√•ndtering. - Supabase Edge Functions: Backend-logikk som krever serverside kontroll er implementert som Deno-baserte Edge Functions i supabase/functions. De fleste f√∏lger et m√∏nster: h√•ndtere preflight OPTIONS (CORS), hente Supabase-klient med getSupabase(req) som legger ved auth header, validere supabase.auth.getUser() og deretter utf√∏re DB-operasjoner[15][16]. Feil logges (console.error) og returneres som JSON med passende HTTP-status. Vi vil implementere Revisorskolens logikk i slike funksjoner (training-start-run, training-apply-action etc.) med samme struktur.
Forslag filplassering: For √• holde modulen isolert legges nye filer under egne mapper: - Frontend: src/pages/Revisorskolen.tsx for hovedsiden, og en ny mappe src/components/Revisorskolen/ for modul-spesifikke komponenter (RevisionGameBoard.tsx, ActionPicker.tsx, RevealFeed.tsx, ScenarioHeader.tsx). Dette skiller koden tydelig fra eksisterende trening (components/Training) og gj√∏r vedlikehold enklere. - Hooks: src/hooks/useRevisorskolen.ts som samler React Query hooks relatert til spillet (scenario/handlinger/runs). Alternativt kan vi lage flere filer (f.eks. useRevisionRun.ts), men √©n fil for modulens hooks gir oversikt. - Types: Vi utvider src/integrations/supabase/types.ts med v√•re nye tabeller (Supabase genererer typer etter migrering). I mellomtiden kan vi definere interne TS-typer for f.eks. TrainingScenario, TrainingAction, TrainingRun i en fil src/types/training.ts om √∏nskelig. - Edge Functions: Under supabase/functions oppretter vi training-start-run/index.ts, training-apply-action/index.ts (og evt. training-reset-run/index.ts). Vi legger ogs√• felles hjelpefunksjoner i supabase/functions/_shared om n√∏dvendig (f.eks. importere getSupabase for auth, og bruke felles CORS-headere som definert der).
Samlet sett vil Revisorskolen-modulen integreres s√∏ml√∏st ved √• f√∏lge disse m√∏nstrene, slik at venstrepanelet f√•r en ny inngang, ruteh√•ndteringen tar den inn, og modulens kode benytter samme klient- og UI-konvensjoner som resten av prosjektet.
2) üß± Datamodell (Supabase)
Vi trenger nye tabeller i Supabase for √• lagre scenario-definisjoner og brukerspill (runs). Tabellenavn er prefikset med training_ for √• gruppere dem. Under er et forslag til SQL DDL (migreringsskript) for √• opprette tabellene, med n√∏kkelkolonner, relasjoner og indekser:
-- 1. Scenario-spill definisjoner
CREATE TABLE public.training_scenarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  intro_brief_md TEXT,       -- Introduksjon/oppdragsbeskrivelse (Markdown)
  default_budget_hours INT NOT NULL DEFAULT 100,
  risk_objectives TEXT[],    -- (Optional) liste av ‚Äúrisikon√∏kler‚Äù for scenarioets m√•l
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 2. Katalog over mulige handlinger i et scenario
CREATE TABLE public.training_actions_catalog (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  scenario_id UUID REFERENCES public.training_scenarios(id) ON DELETE CASCADE,
  code TEXT NOT NULL,        -- Kort kode/ID for handling (f.eks. "FO1")
  category TEXT NOT NULL,    -- Type handling (foresp√∏rsel, inspeksjon, observasjon, analytisk, gjentakelse)
  title TEXT NOT NULL,       -- Navn/tittel p√• handlingen (for visning i UI)
  cost_hours INT NOT NULL,   -- Tidskostnad i timer
  reveal_key TEXT,           -- Knyttes til en risikon√∏kkel hvis handlingen avsl√∏rer et m√•l
  reveal_markdown TEXT,      -- Markdown-tekst som avsl√∏res n√•r handlingen utf√∏res
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
CREATE INDEX actions_by_scenario ON public.training_actions_catalog(scenario_id);

-- 3. Aktive spill (runs) som brukerne har startet
CREATE TABLE public.training_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  scenario_id UUID REFERENCES public.training_scenarios(id),
  user_id UUID,  -- fylles automatisk med auth.uid() via policy
  total_budget_hours INT NOT NULL,   -- Totalt budsjett (timer)
  used_hours INT NOT NULL DEFAULT 0, -- Akkumulerte forbrukte timer
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  completed_at TIMESTAMP WITH TIME ZONE   -- Null inntil run er ferdig
);
CREATE INDEX runs_by_user ON public.training_runs(user_id);
CREATE INDEX runs_by_scenario ON public.training_runs(scenario_id);

-- 4. Logg over valg brukeren tar i spillet
CREATE TABLE public.training_run_choices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  run_id UUID REFERENCES public.training_runs(id) ON DELETE CASCADE,
  action_id UUID REFERENCES public.training_actions_catalog(id),
  taken_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
CREATE INDEX choices_by_run ON public.training_run_choices(run_id);
Relasjoner: - training_actions_catalog.scenario_id refererer til hvilket scenario handlingen tilh√∏rer. Sletting av et scenario vil slette tilh√∏rende handlinger. - training_runs.scenario_id lar oss knytte en spillgjennomf√∏ring til scenarioet som spilles. user_id feltet fylles av innlogget bruker ‚Äì her legger vi p√• RLS i neste steg. - training_run_choices.run_id knyttes til hvilket run handlingen ble utf√∏rt i, og action_id til selve handlingen fra katalogen. Sletting av et run cascader til valg-loggen.
RLS-policier: Vi aktiverer Radix Level Security for sensitive tabeller og lager policyer som begrenser lesing/skriving til den autentiserte brukeren:
-- Aktiver RLS
ALTER TABLE public.training_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.training_run_choices ENABLE ROW LEVEL SECURITY;

-- Policy: En bruker kan kun se og endre egne runs
CREATE POLICY select_own_runs ON public.training_runs 
  USING (user_id = auth.uid());
CREATE POLICY insert_own_run ON public.training_runs 
  WITH CHECK (user_id = auth.uid());
-- (Merk: Supabase vil sette user_id via function i insert trigger eller i edge function kode)

-- Policy: En bruker kan kun se valg tilh√∏rende egne runs
CREATE POLICY select_own_run_choices ON public.training_run_choices
  USING ( run_id IN (SELECT id FROM public.training_runs r WHERE r.user_id = auth.uid()) );
CREATE POLICY insert_own_choice ON public.training_run_choices
  WITH CHECK ( run_id IN (SELECT id FROM public.training_runs r WHERE r.user_id = auth.uid()) );
For training_scenarios og training_actions_catalog kan vi vurdere √• la dem v√¶re lesbare for alle autentiserte (da de ikke inneholder sensitiv info per bruker). Evt. kan vi begrense lesing til testbrukere/administratorer inntil modulen er public. F.eks.:
ALTER TABLE public.training_scenarios ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_scenarios_for_testusers ON public.training_scenarios
  USING ( auth.role() = 'authenticated' );  -- Evt. sjekk mot profile.role = 'testbruker'
(Ovenst√•ende bruker en enkel auth.role() ‚Äì for mer finmaskede rolle-sjekker kunne man lage en FUNCTION som henter user_role fra profiles for auth.uid(), men dette krever at user_role ligger som claim i JWT eller en VIEW.)
Data-seeding: Vi fyller inn et scenario ‚ÄúNordic Varehandel AS‚Äù og dets handlinger. Under vises eksempel INSERTs for scenarioet (det komplette innholdet leveres i seksjon 11):
INSERT INTO public.training_scenarios (id, title, intro_brief_md, default_budget_hours, risk_objectives) VALUES
  ('00000000-0000-0000-0000-000000000001', 
   'Nordic Varehandel AS', 
   'Nordic Varehandel AS er et mellomstort handelsforetak...\n(Full introduksjonstekst i seksjon 11)',
   100,
   ARRAY['periodisering','ulovlig_laan','varelager_nedskrivning','tapsrisiko_fordringer']
);

INSERT INTO public.training_actions_catalog 
(scenario_id, code, category, title, cost_hours, reveal_key, reveal_markdown) VALUES
-- Eksempel handling:
('00000000-0000-0000-0000-000000000001', 'FO1', 'foresp√∏rsel', 'Sp√∏r CFO om uvanlige transaksjoner', 4, 'ulovlig_laan',
 '*CFO* opplyser at selskapet ga et kortsiktig l√•n til daglig leder p√• 1,5 mill... (osv i seksjon 11)'),
... (flere handlinger her, se seksjon 11) ...;
Vi bruker hardkodet UUID for scenario for tydelighet her, men i praksis lar vi databasen generere nye UUIDer. Fr√∏dataene kan kj√∏res som en migrering eller via Supabase admin GUI. Disse dataene legger til scenario med tilh√∏rende 10‚Äì15 handlinger.
Indekser: Som vist i DDL oppretter vi indekser p√• fremmedn√∏kler (scenario_id, user_id, run_id) for √• effektivisere sp√∏rringer som henter scenarioets handlinger, en brukers aktive run, eller valg for et run.
Denne datamodellen kan justeres etter behov. Vi merker oss at det allerede finnes en tabell test_scenarios i databasen fra f√∏r[17], men den ser ut til √• gjelde et annet konsept (den inneholder felter som industry, annual_revenue mm. for treningsscenarioer generelt). For √• holde Revisorskolen modulens data isolert fra eksisterende ‚Äútraining‚Äù moduler, introduserer vi egne tabeller som definert over. Dette gir oss frihet til √• utvide funksjonalitet (som √• lagre reveal-tekster, budsjett mm.) uten √• p√•virke eksisterende funksjoner.
3) üõ†Ô∏è Edge Functions (Supabase)
Vi lager to hovedfunksjoner for modulens backendlogikk, samt en valgfri til reset. Alle skrives i TypeScript (Deno) med robust feil- og auth-h√•ndtering. De vil benytte Supabase JWT auth (brukerens token) i stedet for service-role der mulig, slik at RLS-policyene v√•re h√•ndheves automatisk.
3.1 training-start-run
Denne endepunktsfunksjonen startes n√•r en bruker initierer et nytt spill. Den skal: - Autorisere brukeren (krever gyldig JWT). - Motta scenario_id (f.eks. i JSON body). - Opprette en ny rad i training_runs med gitt scenario, user_id og initialt budsjett (default 100 timer eller overskrive om scenario har custom budget). - Returnere run-objektet eller i det minste runId og budsjettinfo som respons.
Kode for training-start-run:
// File: supabase/functions/training-start-run/index.ts
import { getSupabase } from '../_shared/supabaseClient.ts'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }
  const supabase = getSupabase(req)
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
  }

  try {
    const { scenario_id } = await req.json()
    if (!scenario_id) {
      return new Response(JSON.stringify({ error: 'Missing scenario_id' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
    }
    // Hent scenario for √• finne default budsjett
    const { data: scenario, error: scenarioError } = await supabase
      .from('training_scenarios')
      .select('default_budget_hours')
      .eq('id', scenario_id)
      .single()
    if (scenarioError || !scenario) {
      console.error('Scenario not found or error:', scenarioError)
      return new Response(JSON.stringify({ error: 'Scenario not found' }), { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
    }

    // Opprett ny run
    const { data: newRun, error: insertError } = await supabase
      .from('training_runs')
      .insert({
        scenario_id: scenario_id,
        user_id: user.id,              // Brukerens egen ID (RLS vil bekrefte dette)
        total_budget_hours: scenario.default_budget_hours ?? 100
      })
      .select('id, total_budget_hours, used_hours')
      .single()
    if (insertError) throw insertError

    return new Response(JSON.stringify({
        runId: newRun.id,
        total_budget_hours: newRun.total_budget_hours,
        used_hours: newRun.used_hours
      }), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
  } catch (error) {
    console.error('Error starting run:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
  }
})
Forklaring: Funksjonen bruker getSupabase(req) fra v√•r _shared util (som legger p√• Auth header)[15]. Den validerer at user finnes[18]. Deretter leser vi JSON-body, henter scenarioet for budsjett (slik at hvis scenario har et spesielt tidsbudsjett, tar vi det). Vi oppretter s√• en ny training_runs rad. Takket v√¶re v√•r RLS trengs ikke service role-key; innsettingen vil automatisk sette user_id siden funksjonen kj√∏rer med brukerens token (alternativt kunne vi hatt en Supabase function for default user_id). Vi velger her √• eksplisitt sette user_id: user.id for klarhet. Insertet returnerer id, total_budget_hours og used_hours (0) for det nye run. Til slutt returneres disse dataene i JSON.
Edge-funksjonen h√•ndterer feil med try/catch, og returnerer 500 med generisk melding for uventede feil. CORS-headere legges alltid p√• svar, og preflight OPTIONS h√•ndteres tidlig for √• tillate kall fra frontend.
3.2 training-apply-action
Dette endepunktet kalles n√•r brukeren utf√∏rer en handling i spillet. Det skal: - Autorisere brukeren. - Motta run_id og action_id (identifiserer hvilket spill og hvilken handling). - Sl√• opp handlingens cost_hours, reveal_markdown og ev. reveal_key. - Validere at brukeren eier runet (RLS dekker dette) og at nok tid gjenst√•r (budsjettsjekk). - Opprette entraining_run_choicesrad for valget. - Oppdateretraining_runs.used_hours(f.eks. √∏ke med cost_hours). - Returnere **reveal-teksten** (Markdown) for handlingen, samt oppdatert timeforbruk (f.eks. nyeused_hoursellerremaining_hours`).
Kode for training-apply-action:
// File: supabase/functions/training-apply-action/index.ts
import { getSupabase } from '../_shared/supabaseClient.ts'
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }
  const supabase = getSupabase(req)
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
  }

  try {
    const { run_id, action_id } = await req.json()
    if (!run_id || !action_id) {
      return new Response(JSON.stringify({ error: 'Missing run_id or action_id' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
    }
    // Hent run for √• sjekke budsjett
    const { data: run, error: runError } = await supabase
      .from('training_runs')
      .select('id, total_budget_hours, used_hours')
      .eq('id', run_id)
      .single()
    if (runError || !run) {
      return new Response(JSON.stringify({ error: 'Run not found' }), { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
    }
    // Hent handling for kostnad og reveal
    const { data: action, error: actionError } = await supabase
      .from('training_actions_catalog')
      .select('cost_hours, reveal_markdown, reveal_key')
      .eq('id', action_id)
      .single()
    if (actionError || !action) {
      return new Response(JSON.stringify({ error: 'Action not found' }), { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
    }
    // Budsjettsjekk
    const remaining = run.total_budget_hours - run.used_hours
    if (action.cost_hours > remaining) {
      return new Response(JSON.stringify({ error: 'Ikke nok timer igjen i budsjettet' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
    }

    // Loggf√∏r valget
    const { error: choiceError } = await supabase
      .from('training_run_choices')
      .insert({ run_id: run_id, action_id: action_id })
    if (choiceError) throw choiceError

    // Oppdater brukt tid i run (√∏ker used_hours)
    const newUsed = run.used_hours + action.cost_hours
    const { error: updateError } = await supabase
      .from('training_runs')
      .update({ used_hours: newUsed })
      .eq('id', run_id)
    if (updateError) throw updateError

    // Valgfritt: hvis handlingens reveal_key fullf√∏rer et m√•l, kunne vi oppdatert noe status ‚Äì men dette h√•ndteres heller i frontend.

    return new Response(JSON.stringify({
        reveal_markdown: action.reveal_markdown,
        reveal_key: action.reveal_key,
        used_hours: newUsed,
        remaining_hours: run.total_budget_hours - newUsed
      }), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
  } catch (error) {
    console.error('Error applying action:', error)
    return new Response(JSON.stringify({ error: 'Internal server error' }), { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } })
  }
})
Forklaring: Vi kj√∏rer tilsvarende auth-sjekk som i start-run. Deretter: - Henter run: Vi gj√∏r .single() select p√• run_id for √• f√• tak i total_budget_hours og used_hours. RLS begrenser til eierens run, s√• hvis brukeren pr√∏ver en run_id som ikke er sin, f√•r vi 404 som h√•ndteres. - Henter handling: Vi sl√•r opp handlingens kostnad og innhold. (Her antar vi at alle handlinger som kan utf√∏res i et run tilh√∏rer scenarioet for runet ‚Äì vi kunne validert ataction.scenario_id == run.scenario_idfor konsistens, men RLS hindrer ikke at man teoretisk sp√∏r en action fra et annet scenario. For sikkerhet kunne vi lagt inn sjekk.) - *Budsjettsjekk:* Vi beregner gjenst√•ende timer. Hviscost_hoursoverskrider dette, returnerer vi 400 med melding ‚ÄúIkke nok timer igjen...‚Äù. - *Logge valget:* Vi inserter inn itraining_run_choicesmed run_id og action_id. Takket v√¶re RLS og foreign key vil dette kun lykkes om brukeren eier runet. (Dersom en onConflict op upsert trengs ikke her ‚Äì samme handling kan tas flere ganger dersom scenario tillater, vi logger bare alle.) - Oppdatere run: Vi beregner newUsed = eksisterende brukt + cost. S√• oppdaterer vi runets used_hours. (Vi kunne ogs√• lagret remaining_hours, men det kan utledes og holdes konsistent ved √• alltid regne ut, s√• vi lagrer kun brukt.) - Response: Vi sender tilbake reveal_markdown (tekstblokken som skal vises til bruker), reveal_key (hvilken n√∏kkel denne infoen h√∏rer til, kan brukes frontent til √• markere m√•l oppn√•dd), samt oppdatert used_hours og kalkulert remaining_hours. Frontend kan bruke disse til √• oppdatere fremdriftsvisning.
Feilh√•ndtering: Som i forrige funksjon catches uventede feil, logger dem p√• server (Supabase vil logge console.error til funksjonsloggene), og returnerer HTTP 500. Vi gir spesifikke 400/404 meldinger for kjente feiltilstander (mangler param, ikke funnet, budsjettfeil).
CORS: Begge funksjoner returnerer alltid de n√∏dvendige CORS-headerne, slik at v√•r webapp (p√• annet domene) kan kalle dem via supabase-js.
3.3 (Valgfri) training-reset-run
For √• st√∏tte restart kunne vi lage en funksjon som tilbakestiller spillet. Mulige implementasjoner: - Soft reset: Sett completed_at p√• gjeldende run og la frontend opprette en ny via start-run. (Man kan argumentere at ny run = ny game session, s√• reset kan h√•ndteres klient-side ved simpelthen √• kalle start-run igjen for scenarioet. Alternativt kan man begrense √©n aktiv run per bruker+scenario.) - Hard reset: Slette eksisterende run og valg. Hvis RLS tillater delete for eier, kan dette gj√∏res i en funksjon.
En enkel variant:
// File: supabase/functions/training-reset-run/index.ts
// ... auth boilerplate ...
    const { run_id } = await req.json()
    if (!run_id) return new Response(...400...)
    // Slette run (cascade sletter choices grunnet FK on delete cascade)
    const { error: deleteError } = await supabase
      .from('training_runs')
      .delete()
      .eq('id', run_id)
    if (deleteError) throw deleteError
    return new Response(JSON.stringify({ success: true }), { ...200 headers... })
Med RLS m√• vi tillate DELETE for egne runs:
CREATE POLICY delete_own_run ON public.training_runs 
  USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());
I praksis er reset-run funksjonen ikke kritisk ‚Äì vi kan la brukeren starte nytt run selv om et tidligere finnes (f.eks. ‚ÄúStart p√• nytt‚Äù kan bare kalle start-run; det nye run‚Äôet vil v√¶re separat). Men for opprydding kan det v√¶re greit √• markere gamle runs som completed eller fjerne dem.
Oppsummering: Disse edge-funksjonene gir oss et sikkert API hvor all kritisk logikk (budsjettnedtrekk, avdekking av info) skjer p√• serveren. Dermed kan ikke brukeren jukse med budsjettet fra klientsiden ‚Äì serveren returnerer kun reveal hvis det er timer igjen. Vi gjenbruker Supabase-klienten med JWT for √• dra nytte av RLS, og f√•r en str√∏mlinjeformet implementasjon lik eksisterende endepunkter i appen.
4) üß© Frontend-arkitektur
Frontend-delen av Revisorskolen best√•r av en ny rute og en samling komponenter for spillgrensesnittet.
Ny route og meny: I App.tsx legger vi inn:
<Route path="revisorskolen" element={<ProtectedRoute><Revisorskolen /></ProtectedRoute>} />
plassert blant de andre ressurs-rutene (for eksempel etter academy-ruten). Dette gj√∏r at n√•r brukeren navigerer til /revisorskolen (f.eks. klikker i menyen), rendres v√•r nye sidekomponent Revisorskolen. I venstremenyens resourceItems array legger vi:
{ title: 'Revisorskolen', url: '/revisorskolen', icon: PlayCircle, roles: ['testbruker'] }
Ikonet PlayCircle fra lucide-react symboliserer et ‚Äúspill‚Äù/simulering. Rollen s√∏rger for at kun brukere merket som testbruker (og evt. admin) ser lenken i menyen. N√•r modul modnes kan vi fjerne rollekriteriet for √• √•pne for alle.
Komponenter: Revisorskolens UI er bygd opp av f√∏lgende React-komponenter: - Revisorskolen.tsx (page): Selve sidesiden for ruten. Denne vil hente scenario-data, h√•ndtere start av spillet og vise hovedspillgrensesnittet (RevisionGameBoard) n√•r et spill er i gang. - RevisionGameBoard.tsx: Hovedspill UI som vises etter at man har startet scenarioet. Den inneholder de tre fanene: Handlinger, Avsl√∏rt info, M√•l & risiko. Den orkestrerer ogs√• barnekomponentene som ActionPicker, RevealFeed og ScenarioHeader. - ActionPicker.tsx: Viser en liste over tilgjengelige handlinger (med kategori-filter). For hver handling viser f.eks. tittel, kategori, tidskostnad og en ‚ÄúKj√∏r handling‚Äù knapp. N√•r knappen trykkes, kalles useApplyAction hook for √• treffe edge-funksjonen og f√• resultat. - RevealFeed.tsx: Viser en ‚Äúfeed‚Äù av informasjon som er avdekket s√• langt. Hver gang brukeren utf√∏rer en handling som har reveal_markdown, legger vi til et kort eller en seksjon i feeden med teksten. Denne teksten kan inneholde formatert Markdown, s√• vi bruker en renderer (f.eks. ReactMarkdown) for √• vise den med riktig styling (vi bruker Tailwinds typografi-klasser som prose for √• formatere markdown-innhold konsistent[19]). - ScenarioHeader.tsx: En toppseksjon som viser scenario-navnet og en fremdriftsindikator for tidsforbruk. Den inneholder f.eks. en progress bar (Radix <Progress> komponent) som fylles i forhold til brukt vs total tid, og tekst som ‚ÄúBrukt X av Y timer‚Äù. Eventuelt kan den ogs√• ha en restart-knapp (‚ÄúStart p√• nytt‚Äù) dersom vi √∏nsker √• tilby resetting i UI. - Statuskort for m√•l: M√•lene/riskoene kan vi vise som en del av RevisionGameBoard. For eksempel under fanen ‚ÄúM√•l & risiko‚Äù kan vi liste hver risikon√∏kkel med et kort som gr√•tt/ul√∏st inntil tilh√∏rende reveal_key er funnet, hvorp√• kortet farges eller markeres ‚Äú‚úÖ‚Äù. Vi kan implementere dette som et enkelt map over scenarioets risk_objectives der vi sjekker mot funn. - Laste- og feiltilstander: Hver del m√• h√•ndtere loading og error. Vi bruker React Query sin status til √• vise spinner og ‚ÄúLaster‚Ä¶‚Äù tekst, samt eventuelle feilmeldinger med <p className="text-destructive">Feil: ...</p> eller toast. For eksempel ved oppstart av scenario viser vi en spinner midt p√• siden.
Hooks for data: Vi definerer custom hooks for Revisorskolen som kapsler kall mot Supabase (b√•de direkte .from og functions.invoke): - useScenario(scenarioId): Henter scenario-info (tittel, intro) fra training_scenarios. Brukes p√• Revisorskolen siden for √• vise introduksjon og navn. - useActionsCatalog(scenarioId): Henter alle handlinger (training_actions_catalog) for scenarioet. Returnerer liste av handlinger (kategorisert). - useRun(runId): Henter et p√•g√•ende run (f.eks. for oppdatering av brukt tid dersom vi trenger sanntid). Vi kan evt. bruke data fra start-run respons og deretter oppdatere manuelt, s√• denne er ikke kritisk. - useRunChoices(runId): Henter alle valgene som er tatt i runet, inkludert tilh√∏rendetraining_actions_catalogdata (for √• f√• reveal teksten). Vi kan skrive.select('*, training_actions_catalog(title, reveal_markdown, reveal_key)')hvis vi har definert DB-relasjoner riktig. -useStartRun(): Mutation-hook som kaller edge functiontraining-start-runvia Supabase JS (supabase.functions.invoke). Tar scenarioId og returnerer opprettet run. P√• success kan invalidere queries for runs eller direkte sette state. -useApplyAction(): Mutation-hook for √• utf√∏re en handling. Tar inn valgt actionId (og runId, hvis vi ikke globalt vet current run). Kallersupabase.functions.invoke('training-apply-action', { body: { run_id, action_id } }). P√• success returnerer den reveal data. Hooken kan h√•ndtere toasts p√• error (f.eks. ved 400 ‚ÄúIkke nok timer igjen‚Äù ‚Äì vise toast med feilmelding) og s√∏rge for √• invalidere/oppdatereuseRun` (for nytt timeforbruk) og legge til ny info i feed.
Integrasjon med UI: N√•r brukeren g√•r til /revisorskolen: 1. Start-fase: Komponent Revisorskolen henter scenario (f.eks. med useScenario). Den viser scenario intro-brief (Markdown) og en Start spill knapp. - N√•r brukeren trykker Start, kaller vi startRunMutation.mutate(scenarioId). Mens denne loader, kan knappen vise en spinner. - Ved suksess f√•r vi runId. Vi lagrer denne i lokal state (eller som del av Revisorskolen komponentens state). 2. Spill-fase: N√•r vi har en aktiv runId, rendrer RevisionGameBoard i stedet for introen. Vi passer scenarioId og runId som props nedover. - RevisionGameBoard kan umiddelbart hente actions via useActionsCatalog(scenarioId) for √• fylle ActionPicker-listen (React Query s√∏rger for caching; mens det laster vises f.eks. ‚ÄúLaster handlinger‚Ä¶‚Äù). - Den viser ogs√• ScenarioHeader med scenario.tittel og progress (0% brukt). - Fanene settes opp med Radix <Tabs>: Tre <TabsTrigger>: ‚ÄúHandlinger‚Äù, ‚ÄúAvsl√∏rt info‚Äù, ‚ÄúM√•l & risiko‚Äù, og tilh√∏rende <TabsContent> der vi putter <ActionPicker>, <RevealFeed> og m√•l/status-innhold. - ActionPicker: f√•r prop actions (listen fra useActionsCatalog) og onActionSelected(actionId). Den kan tilby filtrering: f.eks. en dropdown eller tabs for kategori. En enkel l√∏sning er √• ha en state filterCategory og knapper for hver kategori (hentet fra unike kategorier i actions-listen) som filtrerer lista. - Hvert action presenteres med tittel, kategori (f.eks. som Badge), kostnad (f.eks. ‚Äú5 timer‚Äù) og en knapp ‚ÄúKj√∏r‚Äù. Designmessig kan vi bruke <Card> for hver handling med <CardHeader><CardTitle>...</CardTitle></CardHeader> etc., men en enklere liste med <li> er ok. Vi s√∏rger for √• tydelig vise kostnaden (kanskje et ‚è±-ikon + ‚Äú5t‚Äù). - onActionSelected kaller applyActionMutation.mutate({ runId, actionId }). Mens mutasjonen kj√∏rer kan vi disable knapper (s√• man ikke spammer) og vise en liten spinner i knappen valgt. - Hvis mutasjonen feiler (f.eks. budsjett tomt), bruk toast({ title: "Handling feilet", description: error.message, variant: "destructive" }). Ingen feed-oppdatering skjer da. - Ved suksess, f√•r vi reveal_markdown og eventuelt reveal_key. Da: - Oppdater RevealFeed (f.eks. ved √• pushe et nytt element i lokal state array med {text, key, title} ‚Äì vi kan inkludere action title). - Oppdater m√•lstatus dersom reveal_key matcher en risiko: f.eks. sett et state eller Context for ‚ÄúachievedKeys‚Äù (set). - Oppdater ScenarioHeader progress (√∏kt used_hours). Vi kan enten re-fetch run data (useRun) eller, enklere, kalkulere basert p√• responsen: newUsed = prevUsed + cost. Fordi vi allerede oppdaterte server, kan vi optimistisk oppdatere UI. - Alternativt kalle queryClient.invalidateQueries(['run-choices', runId]) for at useRunChoices hook skal hente oppdatert feed fra server (hvis vi lagrer reveal-tekst server-side). Men i v√•r modell ligger reveal_markdown allerede i actions_catalog, s√• run_choices er mer logg enn n√∏dvendig for UI. Derfor kan feeden holdes i klientstate. - RevealFeed: tar prop f.eks. reveals (liste av allerede avdekket info). Hver reveal kan inkludere reveal_markdown og ev. referanse til hvilken handling (title eller code). Vi rendrer hver i et <Card> eller <div> med f.eks. en liten heading av handlingens navn/kategori og s√• markdown-innhold under. Vi bruker ReactMarkdown for √• tolke Markdown til HTML og style det inn med Tailwind typografi-klasser[19]. Eksempel:
<div className="prose prose-sm max-w-none">
  <ReactMarkdown>{reveal.text}</ReactMarkdown>
</div>
som vil formatere lister, fet skrift osv. iht. design. RevealFeed viser de nyeste funnene √∏verst eller nederst ‚Äì her kan vi beslutte. En scrollable liste der nyeste legges nederst er intuitivt som en logg. - M√•l & risiko: I denne fanen viser vi en oversikt over scenarioets risiko-m√•l. Fra scenario.risk_objectives (en array f.eks. ["periodisering", "ulovlig_laan", ...] med kanskje merkelapper). For hvert m√•l kan vi ha et <Card> eller <Alert> komponent med ikon: - Uoppdaget m√•l: Gr√• eller ‚Äúl√•st‚Äù ikon (f.eks. en l√•s eller advarselstrekant). Tekst beskriver risikoomr√•det (f.eks. "Periodisering av inntekter ikke avklart"). - Oppdaget m√•l: Gr√∏nt ikon (checkmark) og tekst som "Periodiseringsrisiko avdekket!" eller lignende. - Hvordan vite oppdaget? N√•r en reveal_key som matcher m√•l legges til feeden, markerer vi det. Vi kan oppdatere en state achievedObjectives (Set) med key hver gang applyAction gir en reveal_key. Alternativt, vi kan beregne det ved √• sjekke feed: hvis noen reveal har reveal_key == objectiveKey, da er den tatt. Siden feed-state er lett tilgjengelig, kan vi derive. - Alle tekster her skal v√¶re norsk, s√• vi legger inn norsk beskrivelse for hvert risikon√∏kkel i UI. Vi kan lagre et mapping fra key til beskrivelse, f.eks. { "ulovlig_laan": "Ulovlig l√•n til daglig leder", ... } enten i scenario-objektet (kunne lagt inn i risk_objectives som en JSON med n√∏kkel+beskrivelse) eller i kode.
UI-eksempel ‚Äì skisse av Revisorskolen-siden etter start:
[19]
Over: Illustrasjon av bruk av ReactMarkdown og Tailwind prose klasser for formatering av avsl√∏rt info. Vi benytter tilsvarende styling for RevealFeed for √• vise Markdown-innhold tydelig.
// File: src/pages/Revisorskolen.tsx
import { useState } from 'react'
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs'
import { Loader2, PlayCircle } from 'lucide-react'
import { useScenario, useStartRun } from '@/hooks/useRevisorskolen'
import RevisionGameBoard from '@/components/Revisorskolen/RevisionGameBoard'

const Revisorskolen = () => {
  const scenarioId = "<ID for Nordic Varehandel>"  // kunne hentes via route eller konstant hvis kun ett scenario
  const { data: scenario, isLoading: scenarioLoading, error: scenarioError } = useScenario(scenarioId)
  const startRunMutation = useStartRun()
  const [runId, setRunId] = useState<string | null>(null)

  if (scenarioLoading) {
    return <div className="text-center py-10 text-muted-foreground">Laster scenario...</div>
  }
  if (scenarioError) {
    return <div className="text-center py-10 text-destructive">Kunne ikke laste scenario.</div>
  }

  // Hvis run er startet, vis spillbrettet
  if (runId) {
    return (
      <RevisionGameBoard 
        scenario={scenario} 
        runId={runId} 
      />
    )
  }

  // Ellers vis introduksjon og start-knapp
  return (
    <div className="max-w-2xl mx-auto p-4 space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">{scenario.title}</CardTitle>
        </CardHeader>
        <CardContent className="prose max-w-none text-muted-foreground">
          {/* Intro brief markdown */}
          <div dangerouslySetInnerHTML={{ __html: scenario.intro_brief_md || '' }} />
        </CardContent>
      </Card>
      <div className="text-center">
        <Button onClick={() => startRunMutation.mutate(scenarioId, {
            onSuccess: (data) => setRunId(data.runId)
          })}
          className="px-6 py-3 text-lg"
        >
          {startRunMutation.isLoading ? (
            // Viser en spinner p√• knappen mens run opprettes
            <Loader2 className="mr-2 h-5 w-5 animate-spin" />
          ) : (
            <PlayCircle className="mr-2 h-5 w-5" />
          )}
          Start scenario
        </Button>
      </div>
    </div>
  )
}

export default Revisorskolen
I koden over bygges introduksjonen opp som et Card med tittel og tekst (vi antar at intro_brief_md allerede er pre-formatert HTML/Markdown; her for enkelthet bruker vi dangerouslySetInnerHTML. Alternativt kunne vi brukt ReactMarkdown komponenten til √• rendere Markdown-strengen). Start-knappen kaller useStartRun.mutate. Vi benytter onSuccess callback for √• sette runId state n√•r vi f√•r responsen (som inneholder runId). Mens mutasjonen p√•g√•r disable-er vi ikke knappen eksplisitt her, men vi viser en spinner (og knappen kan klikkes flere ganger ‚Äì vi kunne forbedret ved disabled={isLoading}).
// File: src/components/Revisorskolen/RevisionGameBoard.tsx
import { useState } from 'react'
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs'
import { useActionsCatalog, useApplyAction } from '@/hooks/useRevisorskolen'
import ScenarioHeader from '@/components/Revisorskolen/ScenarioHeader'
import ActionPicker from '@/components/Revisorskolen/ActionPicker'
import RevealFeed from '@/components/Revisorskolen/RevealFeed'
import { toast } from '@/hooks/use-toast'

interface RevisionGameBoardProps {
  scenario: { id: string; title: string; default_budget_hours: number; risk_objectives: string[] }
  runId: string
}
const RevisionGameBoard: React.FC<RevisionGameBoardProps> = ({ scenario, runId }) => {
  const { data: actions } = useActionsCatalog(scenario.id)
  const applyActionMutation = useApplyAction(runId)
  // Lokalt state for feed og m√•loppn√•else
  const [revealFeed, setRevealFeed] = useState<Array<{ title: string; text: string; key: string | null }>>([])
  const [achievedKeys, setAchievedKeys] = useState<Set<string>>(new Set())

  const handleActionExecute = (action: { id: string; title: string; cost_hours: number }) => {
    applyActionMutation.mutate(action.id, {
      onSuccess: (data) => {
        // Legg til ny reveal i feeden
        setRevealFeed(prev => [...prev, { title: action.title, text: data.reveal_markdown, key: data.reveal_key }])
        // Oppdater m√•l hvis noen
        if (data.reveal_key) {
          setAchievedKeys(prev => new Set(prev).add(data.reveal_key))
        }
      },
      onError: (error: any) => {
        toast({
          title: "Handling feilet",
          description: error.message || "Kunne ikke utf√∏re handlingen.",
          variant: "destructive"
        })
      }
    })
  }

  return (
    <div className="space-y-4">
      <ScenarioHeader 
        title={scenario.title}
        totalHours={scenario.default_budget_hours}
        usedHours={
          // Bruker summen av cost i feeden som brukt tid, eller hent fra applyAction respons
          revealFeed.reduce((sum, r) => {
            const action = actions?.find(a => a.reveal_markdown === r.text)
            return action ? sum + (action.cost_hours || 0) : sum
          }, 0)
        }
      />
      <Tabs defaultValue="actions">
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="actions">Handlinger</TabsTrigger>
          <TabsTrigger value="feed">Avsl√∏rt info</TabsTrigger>
          <TabsTrigger value="objectives">M√•l & risiko</TabsTrigger>
        </TabsList>
        <TabsContent value="actions">
          <ActionPicker 
            actions={actions || []} 
            onExecute={handleActionExecute} 
            executingActionId={applyActionMutation.isLoading ? applyActionMutation.variables : null}
          />
        </TabsContent>
        <TabsContent value="feed">
          <RevealFeed items={revealFeed} />
        </TabsContent>
        <TabsContent value="objectives">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {scenario.risk_objectives.map(objKey => (
              <div key={objKey} className={`p-4 border rounded-lg ${achievedKeys.has(objKey) ? 'bg-green-50 border-green-600' : 'bg-muted/10 border-muted'}`}>
                <p className={`font-medium ${achievedKeys.has(objKey) ? 'text-green-700' : 'text-muted-foreground'}`}>
                  {achievedKeys.has(objKey) ? '‚úÖ ' : '‚ùì '}
                  {/* Map n√∏kkel til lesbar tekst */}
                  {objKey === 'ulovlig_laan' && 'Ulovlig l√•n til daglig leder'}
                  {objKey === 'periodisering' && 'Periodiseringsrisiko'}
                  {objKey === 'varelager_nedskrivning' && 'Nedskrivningsbehov i varelager'}
                  {objKey === 'tapsrisiko_fordringer' && 'Tapsrisiko i kundefordringer'}
                </p>
              </div>
            ))}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  )
}

export default RevisionGameBoard
I koden over ser vi hvordan data og handlinger bindes sammen: - Vi henter actions med useActionsCatalog(scenario.id) (antar denne returnerer { id, title, cost_hours, reveal_key? ... } for hver handling). - applyActionMutation = useApplyAction(runId) er v√•r mutation-hook. Vi bruker lokal revealFeed state (array) for √• lagre avdekket info. - handleActionExecute tar inn en action og kaller mutate. I onSuccess legger vi til en ny feed-entry med action tittel og reveal tekst. Vi oppdaterer ogs√• achievedKeys dersom reveal_key finnes i responsen. (Merk: i dette eksempel antas applyActionMutation gir data med reveal_markdown og reveal_key). - ScenarioHeader rendres med brukt tid. Her har vi for demo beregnet usedHours ved √• summere cost_hours for actions i feeden. En bedre m√•te: f√• used_hours fra applyAction respons ogs√• (vi returnerte det), s√• vi kunne ha oppdatert en usedHours state direkte. For enkelthet viser vi summasjonsmetoden. - Vi bruker <Tabs> fra shadcn/ui. Hver faneknapp har en label p√• norsk. - Under ‚ÄúHandlinger‚Äù fanen rendres ActionPicker. - Under ‚ÄúAvsl√∏rt info‚Äù rendres RevealFeed. - Under ‚ÄúM√•l & risiko‚Äù fanen mapper vi scenarioets risk_objectives. Hvert m√•l vises som en boks der vi kondisjonelt formaterer avhengig av om achievedKeys inneholder n√∏kkelen. Her er det brukt en enkel ternary med bakgrunnsfarge (gr√∏nn lys bakgrunn hvis oppn√•dd). Vi legger p√• en emoji (‚úÖ for oppn√•dd, ‚ùì for ikke oppn√•dd) for rask visuell indikasjon. Teksten er n√∏kkelens beskrivelse ‚Äì vi mapper manuelt i dette eksempel. (I praksis kunne vi lagret fulle beskrivelser i risk_objectives som et JSON array av objekter med {key, label}, men n√• hardkoder vi mapping for klarhet.) - executingActionId prop til ActionPicker kan brukes for √• disable kun den action-knappen som p√•g√•r hvis √∏nskelig (her passes applyActionMutation.variables som holder sist mutate input hvis isLoading).
// File: src/components/Revisorskolen/ActionPicker.tsx
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { useState } from 'react'

interface Action {
  id: string;
  code?: string;
  category: string;
  title: string;
  cost_hours: number;
}
interface ActionPickerProps {
  actions: Action[];
  onExecute: (action: Action) => void;
  executingActionId: string | null;
}
const ActionPicker: React.FC<ActionPickerProps> = ({ actions, onExecute, executingActionId }) => {
  const categories = Array.from(new Set(actions.map(a => a.category)))
  const [filter, setFilter] = useState<string | null>(null)
  const visibleActions = filter ? actions.filter(a => a.category === filter) : actions

  if (!actions.length) {
    return <p className="text-muted-foreground">Laster handlinger...</p>
  }

  return (
    <div className="space-y-4">
      {/* Kategori-filter knapper */}
      <div className="flex gap-2 mb-2">
        <Button variant={!filter ? "secondary" : "outline"} size="sm" onClick={() => setFilter(null)}>
          Alle
        </Button>
        {categories.map(cat => (
          <Button key={cat} variant={filter===cat ? "secondary" : "outline"} size="sm" onClick={() => setFilter(cat)}>
            {cat.charAt(0).toUpperCase() + cat.slice(1)}{/* kapitaliser kategori navn */}
          </Button>
        ))}
      </div>
      {/* Liste over handlinger */}
      <ul className="space-y-3">
        {visibleActions.map(action => (
          <li key={action.id} className="p-4 border rounded-lg flex items-center justify-between">
            <div>
              <p className="font-medium">{action.title}</p>
              <div className="text-sm text-muted-foreground">
                <Badge variant="outline" className="mr-2">{action.category}</Badge>
                {action.cost_hours} timer
              </div>
            </div>
            <Button 
              onClick={() => onExecute(action)}
              disabled={!!executingActionId}
            >
              {/* Kan evt. vise liten spinner hvis action.id === executingActionId */}
              Kj√∏r
            </Button>
          </li>
        ))}
      </ul>
    </div>
  )
}
export default ActionPicker
I ActionPicker: - Vi kalkulerer unike kategorier fra actions-listen. Viser filter-knapper (‚ÄúAlle‚Äù + per kategori). N√•r en kategori velges settes filter state. - Filterer action-listen basert p√• valgt kategori. - Renderer en <ul> med <li> for hver synlig handling: - Viser title som hovedtekst. - Under viser kategori (som Badge) og tidskost (sm√• gr√• bokstaver). - Til h√∏yre en ‚ÄúKj√∏r‚Äù knapp. Vi disabler knappen hvis en handling er under utf√∏relse (executingActionId prop settes n√•r mutation kj√∏rer; i eksempelet har vi disabled alle knapper ved isLoading ‚Äì man kan utvide til kun disable den ene som kj√∏rer). - Vi kapitaliserer kategori-navnet for visning (f.eks. "foresp√∏rsel" -> "Foresp√∏rsel").
// File: src/components/Revisorskolen/RevealFeed.tsx
import ReactMarkdown from 'react-markdown'

interface RevealFeedProps {
  items: Array<{ title: string; text: string; key: string | null }>
}
const RevealFeed: React.FC<RevealFeedProps> = ({ items }) => {
  if (items.length === 0) {
    return <p className="text-muted-foreground">Ingen informasjon avdekket enda.</p>
  }
  return (
    <div className="space-y-4 max-w-2xl">
      {items.map((item, idx) => (
        <div key={idx} className="p-4 border rounded-lg bg-background">
          <p className="mb-2 font-semibold">{item.title}</p>
          <div className="prose prose-sm">
            <ReactMarkdown>{item.text}</ReactMarkdown>
          </div>
        </div>
      ))}
    </div>
  )
}
export default RevealFeed
I RevealFeed: - Hvis ingen reveals enda, vises en hjelpetekst ‚ÄúIngen informasjon avdekket enda.‚Äù - Ellers itererer vi over items og viser hver som et kort. For hver: - Viser handlingens tittel som fet overskrift (s√• brukeren vet hvilken handling ga denne infoen). - Renderer Markdown-innholdet i item.text via <ReactMarkdown>. Vi har pakket den i en <div className="prose prose-sm"> for stil (som i ActionableMessage komponenten i kodebasen[19]). - Kortene legges i space-y-4 stack for visuell separasjon.
// File: src/components/Revisorskolen/ScenarioHeader.tsx
import { Progress } from '@/components/ui/progress'

interface ScenarioHeaderProps {
  title: string
  totalHours: number
  usedHours: number
}
const ScenarioHeader: React.FC<ScenarioHeaderProps> = ({ title, totalHours, usedHours }) => {
  const remaining = totalHours - usedHours
  const percent = Math.round((usedHours / totalHours) * 100)
  return (
    <div className="p-4 bg-muted/10 rounded-lg">
      <h2 className="text-xl font-bold mb-2">{title}</h2>
      <div className="flex items-center justify-between mb-1 text-sm">
        <span>Brukt: <strong>{usedHours}t</strong> / {totalHours}t</span>
        <span>Gjenst√•r: <strong>{remaining}t</strong></span>
      </div>
      <Progress value={percent} className="w-full" />
    </div>
  )
}
export default ScenarioHeader
I ScenarioHeader: - Vises scenarioets title i et tydelig <h2>. - Viser to sm√• tekster: en for hvor mye som er brukt av totalen, og en for hvor mye som gjenst√•r. Tallene er uthevet. - Under ligger en <Progress> bar (fra Radix, integrert via shadcn/ui) med value={percent} hvor percent er brukt% av budsjett. Progress-baren har default styling (vi kunne tilpasset farger via Tailwind, men bruker systemets prim√¶rfarge). - Alt er lagt i en bakgrunn (‚Äúbg-muted/10‚Äù gir en svak gr√• bakgrunn) og litt padding, for √• se ut som en info-boks i toppen.
Denne frontend-arkitekturen oppfyller kravene: - shadcn/ui bruk: Vi benytter Button, Badge, Card, Progress, Tabs osv. som vist. Styling er konsekvent med appen (muted-foreground, bg-background etc.). - Norsk tekst: Alle synlige strenger er p√• norsk (Laster..., Start scenario, Handlinger, M√•l & risiko, osv.). - Loading/feil: Vi viser ‚ÄúLaster‚Ä¶‚Äù mens scenario laster, og h√•ndterer feil med meldinger/toasts. Under applyAction viser vi feil med toast (r√∏d variant). - Toasts: Integrert via toast() fra use-toast hook. - A11y: Ved √• bruke semantiske elementer (ul/li for lister, h2 for tittel, button for knapper), samt aria-label p√• ikoner der det gir mening (vi kunne legge aria-label="Start scenario" p√• Start-knappen hvis ikonet var uten tekst, men her har knappen tekst, s√• det g√•r bra). Tabs fra Radix er ogs√• a11y-by-design.
Til slutt s√∏rger vi for √• legge denne modulen til i dokumentasjon og config der det trengs (f.eks. dersom noen .env variabler trengs for supabase functions URL etc., m√• dette dokumenteres ‚Äì se Leveranseplan og Dokumentasjon under).
5) üìä Datasett-tilkobling (MVP+)
I scenarioet er det √∏nskelig at visse analytiske handlinger kan kobles mot faktiske datasett (f.eks. hovedbok, aldersfordelt kundeliste, lagerliste) lagret i Supabase Storage. I f√∏rste versjon bruker vi dummy-data, men vi skisserer hvordan dette kan utvides:
Lagring av datasett: Vi kan legge CSV/Excel-filer i en egen Storage bucket (f.eks. training-files). For ‚ÄúNordic Varehandel AS‚Äù scenarioet kan vi ha filer som nordic_gl.csv (hovedbok), nordic_ar.csv (accounts receivable aging), nordic_inventory.csv. Disse kan lastes opp manuelt eller via en admin-grensesnitt i appen. For MVP holder det √• ha de statisk tilgjengelig.
Referanse fra handling: Vi kan utvide training_actions_catalog med et felt, f.eks. dataset_filename eller dataset_key, som indikerer at handlingens reveal inkluderer data. For eksempel kan handling ‚ÄúAnalysere aldersfordeling av kundefordringer‚Äù ha dataset_key: 'nordic_ar.csv'. Edge-funksjonen training-apply-action kan da inkludere logikk som:
if (action.dataset_key) {
  // Last ned fil fra Storage
  const { data: file, error: fileError } = await supabase
    .storage.from('training-files')
    .download(action.dataset_key)
  if (!fileError && file) {
    const csvText = await file.text()
    // Vi kan returnere CSV-innholdet, eller behandle det 
    return new Response(JSON.stringify({ 
       reveal_markdown: action.reveal_markdown, 
       dataset: csvText 
    }), { ... })
  }
}
Men det enkleste er √• la frontenden hente datasetet n√•r det trengs: f.eks. i RevealFeed n√•r en bestemt reveal vises. Alternativt kan reveal_markdown selv inneholde en forh√•ndsformatert tabell eller graf som tekst (men mer elegant er √• vise en interaktiv visualisering).
Presentasjon i frontend: Si at brukeren utf√∏rer handling ‚ÄúAnalytisk gjennomgang av kundefordringer‚Äù og reveal_markdown er noe ala: ‚ÄúDet aldersfordelte kundediagrammet er vist under.‚Äù I tillegg √∏nsker vi √• vise en graf eller tabell. Vi kan implementere det slik: - N√•r reveal_key === 'tapsrisiko_fordringer' (v√•r kundefordring-risk), kan RevealFeed gjenkjenne dette og eksempelvis rendre en <BarChart> fra Recharts basert p√• tilgjengelige data. - Vi kan hardkode i frontend litt demo-data for MVP (f.eks. et array som tilsvarer aldersfordeling), eller faktisk laste fra Storage.
For eksempel, en enkel implementasjon: i RevealFeed, dersom item.key === 'tapsrisiko_fordringer', s√• last ned data fra storage via supabase-js:
if (item.key === 'tapsrisiko_fordringer') {
  supabase.storage.from('training-files').download('nordic_ar.csv').then(res => {
    if(res.data) {
      parseCSVandPlot(res.data)
    }
  })
}
Men bedre er kanskje at edge-funksjonen returnerte et bearbeidet dataset. For konsept-bevis, vi viser et kodeeksempel for hvordan vi kan lese CSV og vise en enkel graf:
import { BarChart, Bar, XAxis, YAxis, Tooltip } from 'recharts';
import Papa from 'papaparse';

// In React component after receiving CSV text:
const result = Papa.parse(csvText, { header: true });
const data = result.data; // e.g. [{ "alder": "0-30 dager", "belop": 50000 }, ...]

// Render with Recharts:
<BarChart width={300} height={200} data={data}>
  <XAxis dataKey="alder" />
  <YAxis />
  <Tooltip />
  <Bar dataKey="belop" fill="#8884d8" />
</BarChart>
I praksis ville vi style grafen bedre og kanskje bruke formatters for tall (f.eks. i kroner). Men dette viser prinsippet: vi parser CSV (her bruker vi papaparse eller d3.csv etc.), og mapper det til Recharts komponenter for visning. Siden appen allerede har Recharts i dependencies[20], er det rett frem √• bruke.
Dyp-lenke til eksisterende sider: Alternativ til custom visning i Revisorskolen er √• lenke brukeren til modulene som allerede finnes i appen for dataanalyse. For eksempel, hvis en handling gjelder hovedbok, og systemet har en side /clients/:clientId/general-ledger med detaljert visning, kunne reveal-teksten inkludere en lenke. Men siden Nordic Varehandel AS ikke er en faktisk klient i systemet, er det enklere √• vise data i-modul.
Oppsummert for MVP er fokus √• vise at modulen kan presentere data. Vi kan initialt legge dummy-tabeller i reveal_markdown (f.eks. som Markdown-tabell eller preformatert tekst). Senere kan vi implementere at en spesiell komponent i RevealFeed gjenkjenner en kode og laster inn data/diagram. Dette er et forbedringspunkt som vi planlegger i et senere PR (se Leveranseplan).
6) ‚úÖ Akseptansekriterier
For at modulen ‚ÄúRevisorskolen‚Äù skal anses som fullf√∏rt og klar for testing, m√• f√∏lgende kriterier oppfylles:
‚Ä¢	Navigasjon & tilgang:
‚Ä¢	Venstremenyen viser ‚ÄúRevisorskolen‚Äù for brukere med riktig rolle (f.eks. testbrukere). Ikonet og teksten er synlig der forventet (mellom Kunnskapsbase og L√¶ring, hvis vi f√∏lger rekkef√∏lgen i resourceItems[5]).
‚Ä¢	√Ö klikke ‚ÄúRevisorskolen‚Äù ruter brukeren til /revisorskolen uten feil. Siden laster scenariointroduksjonen korrekt.
‚Ä¢	Start og budsjettlogikk:
‚Ä¢	N√•r brukeren trykker ‚ÄúStart scenario‚Äù, opprettes et nytt run p√• server (verifiser i Supabase DB at training_runs fikk en ny rad med korrekt user_id). Brukeren skal se spillets hovedgrensesnitt med 100 timer tilgjengelig (eller scenarioets definerte budsjett).
‚Ä¢	Tidbudsjettet trekkes p√• server ved hver handling. Pr√∏v √• utf√∏re flere handlinger og bekreft at training_runs.used_hours √∏ker korrekt og at remaining_hours i responsen stemmer. Fors√∏k √• overskride budsjett (f.eks. hvis 2 timer gjenst√•r og man pr√∏ver en handling p√• 4 timer) ‚Äì da skal edge-funksjonen returnere feilmelding og ingen reveal gis, og UI skal h√•ndtere det (toast ‚ÄúIkke nok timer igjen‚Äù).
‚Ä¢	Brukeren kan fullf√∏re scenarioet ved √• bruke opp eller avsl√∏re alle n√∏kler. N√•r budsjettet er tomt, skal ikke flere handlinger v√¶re mulig (knappene kan deaktiveres eller ytterligere fors√∏k gir feilmelding).
‚Ä¢	Funksjonalitet for handlinger og feed:
‚Ä¢	Ved valg av en handling i ‚ÄúHandlinger‚Äù-fanen:
o	Info-teksten til handlingen dukker opp under ‚ÄúAvsl√∏rt info‚Äù umiddelbart etter at server har svart. Teksten skal v√¶re formatert iht. Markdown (teste at lister, fet skrift etc. fungerer i RevealFeed).
o	Tidsbruken oppdateres b√•de i progress bar og tekstlig i ScenarioHeader.
o	Hvis handlingen var knyttet til en risikon√∏kkel, skal den tilh√∏rende m√•l-flisen under ‚ÄúM√•l & risiko‚Äù endre status (f√• checkmark/‚Äúl√∏st‚Äù).
‚Ä¢	Listen over handlinger oppdateres korrekt (vi fjerner ikke handlinger n√•r de er brukt, siden spilleren kan i prinsippet gj√∏re dem flere ganger ‚Äì men man kan vurdere √• markere dem f.eks. med annen farge).
‚Ä¢	Filter p√• kategorier i ActionPicker fungerer (knappene ‚ÄúAlle‚Äù, ‚ÄúForesp√∏rsel‚Äù, ‚ÄúInspeksjon‚Äù, osv. filtrerer synlig liste).
‚Ä¢	Loading-tilstander er synlige: f.eks. n√•r scenariointro laster vises ‚ÄúLaster‚Ä¶‚Äù, n√•r en handling p√•g√•r er ‚ÄúKj√∏r‚Äù-knappen midlertidig disabled eller viser spinner.
‚Ä¢	Datasikkerhet:
‚Ä¢	RLS-policyer fungerer: En bruker skal kun f√• opp sine egne runs og valg. Fors√∏k √• manuelt bygge et REST-kall (via Supabase API) for √• hente en annen brukers run (f.eks. med en annen JWT) ‚Äì det skal returnere 0 rader.
‚Ä¢	Edge-funksjonene skal kreve auth. Uten gyldig JWT f√•r man 401.
‚Ä¢	Det skal ikke v√¶re mulig √• jukse til seg n√∏kkel-info uten √• bruke riktig funksjon. (Test: Direkte .select p√• training_actions_catalog er mulig for √• se reveal_markdown? ‚Äì Kanskje vi skal vurdere √• ikke gi read-access til actions_catalog for vanlige brukere, og i stedet kreve at reveal kun kommer via funksjon. Men i f√∏rste omgang er reveal_markdown ikke sensitiv uten kontekst, s√• det g√•r greit.)
‚Ä¢	UI/UX:
‚Ä¢	All tekst er p√• norsk. Terminologi er konsistent med fagomr√•det (f.eks. ‚ÄúGjennomf√∏r handling‚Äù vs ‚ÄúKj√∏r‚Äù ‚Äì vi valgte ‚ÄúKj√∏r‚Äù for knapp, det b√∏r v√¶re intuitivt).
‚Ä¢	Det visuelle uttrykket passer med resten av appen: farger er fra tema (ingen skarpe avvik), komponenter har samme stil (f.eks. kort, badges).
‚Ä¢	Applikasjonen er responsiv: Tabs-layouten fungerer p√• sm√• skjermer (Radix Tabs blir stacked eller scroll, men det g√•r greit).
‚Ä¢	Tilgjengelighet: Faner kan navigeres med tastatur, kontrast p√• tekst er tilstrekkelig (Tailwind tokens sikrer dette basert p√• design).
‚Ä¢	Testbruker-rolle: Om vi innf√∏rer ny rolle "testbruker", verifiser at en bruker med denne rollen (sette via RoleAccessAdmin UI eller direkte i profiles.user_role) ser Revisorskolen i meny og kan bruke modulen, mens en vanlig employee ikke ser menyvalget (f√∏r det eventuelt √•pnes opp).
Oppfyllelse av alle punktene over skal demonstreres f√∏r vi kaller oppgaven ferdig. Spesielt viktig er det at budsjettnedtrekket skjer korrekt p√• server, og at ingen overskridelse eller uautorisert tilgang slipper igjennom (dette kan testes med enhetstester og manuelle fors√∏k).
7) üß™ Testplan
Vi planlegger en kombinasjon av enhetstester, komponenttester og ende-til-ende tester for Revisorskolen:
Enhetstester (Vitest): - Hooks og utils: Skriv tester for useStartRun og useApplyAction. Ved bruk av Vitest kan vi mocke supabase.functions.invoke. Test at: - useStartRun sender riktig payload og h√•ndterer suksess (setter data.runId) og feil (kaster eller returnerer error). Vi kan simulere en vellykket respons og se at hookens onSuccess-callback trigges. - useApplyAction ‚Äì mock supabase.functions.invoke til √• returnere f.eks. { reveal_markdown: "...", used_hours: 10 }. Test at hook kaller supabase riktig, og at error h√•ndteres (vi kan forvente at error f√∏rer til at hook setter error state som vi kan asset). - Tidsberegning utils: Hvis vi har en separat funksjon for √• beregne gjenst√•ende tid eller prosent (f.eks. i ScenarioHeader), test den med ulike inputs (100 total, 40 brukt => 60 igjen, 40%). - Edge functions: Vi kan benytte Deno sitt test-runner for √• kj√∏re funksjonene isolert. F.eks. kalle training-apply-action handler-funksjonen med en mock Request som inneholder JWT + JSON body, og asset at vi f√•r forventet Response (200 eller 400). Dette kan gj√∏res ved √• stubbe supabase-klienten. (Supabase tilbyr mulighet for lokal testing med supabase-functions serve, men for enhetstester kan vi eventuelt abstrahere budsjettkontroll i en pure function for test.)
Komponenttester (React Testing Library): - ActionPicker: Render komponenten med et mock actions-list (f.eks. 2-3 actions med forskjellige kategorier). Assert at alle titler vises. Klikk p√• kategori-filter og assert at listen filtreres. Simuler klikking ‚ÄúKj√∏r‚Äù og sjekk at onExecute callback kalles med korrekt action (bruk RTL sin fireEvent). Test at n√•r executingActionId prop er satt, knapper er disabled. - RevealFeed: Gi komponenten en liste med items (noen med markdown-syntax, f.eks. **bold**). Bruk screen.getByText for √• finne snippet av teksten for hver item. Test at Markdown er rendret ‚Äì f.eks. at <strong> element finnes rundt "bold" tekst (RTL kan f√• tak i DOM elements). - ScenarioHeader: Med forskjellige props, sjekk at riktig prosent vises. For eksempel, rendrer <ScenarioHeader totalHours=100 usedHours=50> og forvent at screen.getByText("50 / 100") finnes og at Progress-bar value reflekerer 50%. - RevisionGameBoard integrasjon: Vi kan skrive en test som renderer RevisionGameBoard med mock scenario og actions, men det krever mocking av hooks. Alternativt kan vi teste at fanene bytter innhold: f.eks. klikk p√• ‚ÄúAvsl√∏rt info‚Äù fanen og forvent at ActionPicker-innholdet ikke lenger er i DOM, mens RevealFeed er. - Bruk i test gjerne vi.mock('@/hooks/useRevisorskolen') for √• kontrollere returverdier.
E2E tester (Cypress/Playwright): Vi lager E2E-skript som dekker et helt brukerforl√∏p: 1. Start spill: Logg inn som testbruker i app (Cypress kan bruke testkonto). Naviger til /revisorskolen. Klikk ‚ÄúStart scenario‚Äù. Forvent at siden bytter fra intro til spillvisning (f.eks. assert at ‚ÄúHandlinger‚Äù fanen dukker opp). 2. Utf√∏r handling: I Handlinger-listen, klikk p√• en handling med kjent utfall (f.eks. en som avsl√∏rer en n√∏kkel). Etter klikk, vent p√• at feed oppdateres. Assert at feeden n√• inneholder forventet tekst (f.eks. s√∏k etter et n√∏kkelord fra reveal_markdown). Assert at ScenarioHeader timer er redusert (f.eks. hvis cost 5, sjekk at ‚Äú5/100‚Äù brukes n√•). 3. M√•l oppdatert: Hvis handlingen skulle markere et m√•l, bytt til ‚ÄúM√•l & risiko‚Äù fanen og assert at riktig m√•l st√•r som fullf√∏rt (f.eks. gr√∏nn tekst eller ‚úÖ). 4. Budsjett: Utf√∏r flere handlinger til budsjettet er lavt. Pr√∏v en handling som overstiger ‚Äì assert at UI viser feilmelding (f.eks. toast med tekst). 5. Tilbakestilling: (Hvis implementert reset) Klikk ‚ÄúStart p√• nytt‚Äù og se at timer resettes og feed t√∏mmes.
Testene skal kj√∏re gr√∏nt i CI. Vi b√∏r ogs√• inkludere testdata i testmilj√∏et: f.eks. migrere database til test, populere Nordic Varehandel scenario. Alternativt kan vi mocke backend i Cypress (til n√∏d).
Testdata og seeding: Vi lager likelydende data for test som for produksjon seed. I test-runner (f.eks. Vitest globalSetup) kunne vi opprette et in-memory supabase instance eller bruke testmilj√∏-Supabase. Dette er avansert; vi kan n√∏ye oss med integrasjonstesting mot dev.
Samlet vil denne testplanen fange opp b√•de isolerte funksjonsfeil (enhet), korrekt rendering og interaksjon (component tests), og full flow (E2E), og dermed gi trygghet f√∏r vi leverer modulen til pilotbrukere.
8) üöÄ Leveranseplan / PR-batching
For √• introdusere Revisorskolen kontrollert og sikre kvalitet deler vi arbeidet i flere pull requests:
‚Ä¢	PR1: Database & backend grunnlag.
‚Ä¢	Inneholder SQL-migrasjonsskript for opprettelse av training_* tabeller, indekser og RLS-policyer. Dette skriptet kj√∏res i Supabase migrasjoner (f.eks. via supabase_migrations systemet).
‚Ä¢	Seed-data for scenario ‚ÄúNordic Varehandel AS‚Äù og dens handlinger (INSERTs som vist).
‚Ä¢	Oppdater .env.example med eventuell ny konfig (f.eks. hvis vi trenger en bucket definert).
‚Ä¢	Dokumenter i PR-beskrivelse hvordan migrasjonen kan rulles tilbake (DROP TABLEs i omvendt rekkef√∏lge hvis needed).
‚Ä¢	Changelog: Noter nye tabeller og funksjoner.
‚Ä¢	Status: Etter PR1 er backenden klar, men ingen frontend bruker det enda, s√• ingen synlig endring for brukere.
‚Ä¢	PR2: Supabase Edge Functions + Integrasjon.
‚Ä¢	Legg til filene training-start-run, training-apply-action (+ evt. reset) i repo under supabase/functions.
‚Ä¢	Skriv enhets-/Deno-tester for disse.
‚Ä¢	Deploy funksjonene til Supabase (beskrevet i README hvordan).
‚Ä¢	Integrer funksjonene i frontend-hookene (useStartRun bruker supabase.functions.invoke).
‚Ä¢	Sannsynligvis trenger vi her √• utvide Supabase CORS innstillinger om ikke '*' er default for deployede funksjoner. (Kan gj√∏res via supabase functions deploy ... som tar med CORS i koden).
‚Ä¢	Changelog: Nye endepunkter dokumentert.
‚Ä¢	Etter PR2 kan man (for de tekniske) kalle funksjonene via API for √• teste, men ingen UI enn√•.
‚Ä¢	PR3: Frontend modul UI.
‚Ä¢	Legg til route i App.tsx og meny i ResizableLeftSidebar.tsx.
‚Ä¢	Opprett alle React-komponentene beskrevet (Revisorskolen.tsx, RevisionGameBoard.tsx, ScenarioHeader.tsx, ActionPicker.tsx, RevealFeed.tsx).
‚Ä¢	Lag hooks i useRevisorskolen.ts for datahenting (disse kan bruke supabase JS til .from for scenario/actions, siden RLS tillater).
‚Ä¢	Koble hooks til komponenter som vist.
‚Ä¢	UI/UX test: manuelt gjennomg√• modul i browser med testdata.
‚Ä¢	Changelog: Beskriv den nye modulen og at den initialt er for testbrukere.
‚Ä¢	Dokumentasjon: Oppdater README eller docs med evt. info (f.eks. at man m√• kj√∏re DB migrasjon, og at testbruker-rolle b√∏r settes for √• se modulen).
‚Ä¢	Etter PR3 er funksjonaliteten ende-til-ende, klar for interne testere.
‚Ä¢	PR4: Datasett-visning & E2E tester (valgfri/oppf√∏lgende).
‚Ä¢	Implementer forbedret datasett-tilkobling: f.eks. legg til at reveal_feed gjenkjenner visse keys og viser en <BarChart> med dummydata eller trekker faktisk fil fra Storage. Alternativt levere en enkel tabell i reveal_markdown (som midlertidig l√∏sning).
‚Ä¢	Skriv E2E testene beskrevet i Testplanen (Cypress konfig ligger muligens fra f√∏r, jmf. README og package.extend.json for Cypress).
‚Ä¢	Oppdater eventuell docs for hvordan man laster opp datafiler til Supabase Storage for scenarioer.
‚Ä¢	Changelog: Noter at modulen n√• viser eksempel grafer/tabeller for data.
‚Ä¢	Milj√∏variabler: Ingen nye antatt her, men hvis vi trenger f.eks. en SERVICE_ROLE key i frontend for spesielle funksjoner (forh√•pentligvis ikke, vi holder oss til anon + RLS).
‚Ä¢	Rollback: PR4 er features som kan toggles av hvis feil (man kan kommentere ut data-visning uten at core funk g√•r ned).
Hver PR skal gjennom kodegjennomgang. Siden dette er en relativt stor modul, kan PR3 spesielt bli stor ‚Äì vurder √• splitte PR3 i to: f√∏rst layout + basis hooks (uten faktisk funksjonskall), deretter kobling mot backend. Men gitt at modul er isolert, √©n PR kan v√¶re h√•ndterlig.
Vi lager i tillegg en feature toggle mulighet: f.eks. en env VITE_ENABLE_TRAINING_GAME som hvis false skjuler Revisorskolen fra UI helt. Slik kan modulen merges til main, men inaktiv i prod til vi √∏nsker pilotere. Dette kan legges som sjekk rundt menypunktet og ruten.
9) üìà Telemetri og drift
For √• f√∏lge med p√• bruk og sikre god drift, legger vi inn:
‚Ä¢	Logging av kall: Edge-funksjonene logger allerede til console (Supabase Functions logg) ved feil. Vi kan utvide med informasjonslogger. For eksempel i training-start-run etter suksess kan vi console.log("New run started by", user.id, "for scenario", scenario_id). I training-apply-action, logge console.log(\Action ${action_id} applied in run ${run_id}, remaining: ${remaining_hours}`)`. Disse loggene er s√∏kbare i Supabase dashboard under Functions logs, og kan integreres med f.eks. Logflare om satt opp.
‚Ä¢	Kostnads-telemetri: Vi kan lage en trigger eller bare aggregere fra DB:
‚Ä¢	Legg evt. inn en postgress VIEW: training_run_stats som joiner runs og choices for √• regne ut totalt antall handlinger tatt, gjenv√¶rende tid etc.
‚Ä¢	En enklere tiln√¶rming: i Edge-funksjonen apply-action, etter suksess, kall supabase og √∏k en teller i en egen stats-tabell. F.eks. training_stats med kolonner scenario_id, total_runs, total_actions, total_hours_consumed. Vi kan oppdatere total_actions = total_actions + 1, total_hours_consumed = total_hours_consumed + action.cost_hours i funksjonen (med service_role eller definert RLS-policy for en aggregator-bruker). Dette gir oss mulighet til √• lage en admin-dashboard senere som viser f.eks. ‚ÄúGjennomsnittlig forbrukte timer: X‚Äù eller ‚ÄúOppdaget 4/4 n√∏kler i Y% av runs‚Äù.
‚Ä¢	Forel√∏pig kan man manuelt sjekke stats ved queries som:
 	SELECT 
  COUNT(*) as runs_started,
  (SELECT COUNT(*) FROM training_run_choices) as total_actions_taken,
  AVG(used_hours) as avg_hours_used
FROM training_runs;
 	Dette kan kj√∏res i Supabase SQL-editor etter noen gjennomf√∏ringer.
‚Ä¢	Overv√•kning av feil: Implementer global error boundary / Sentry logging (hvis Sentry integrasjon finnes fra f√∏r, legg til event tagging for modul). Edge-funksjoner kan integreres med Supabase Metrics for antall kall, feilrate etc.
‚Ä¢	Vi b√∏r sette opp alarm hvis apply-action begynner √• feile ofte (kan indikere bug eller misbruk).
‚Ä¢	Rate-limiting: Siden funksjonene er authed pr bruker og budsjett er begrenset, er misbruk lite sannsynlig, men Supabase har per minutt begrensninger p√• funksjonskall som uansett hindrer DoS.
‚Ä¢	Dashboard for bruk: P√• sikt kan vi lage en enkel side i adminpanelet som lister scenarioer og antall runs, snitt score (hvor mange m√•l funnet). Dette kan gj√∏res ved √• lese training_runs og training_run_choices. For n√• kan vi bruke Supabase selv: deres ‚ÄúTable editor‚Äù for √• observere data, eller lage en liten SQL-snutt i docs.
‚Ä¢	Driftsrutiner:
‚Ä¢	Opprydning: Hvis mange testbrukere kj√∏rer spillet, vil training_run_choices vokse. Vi kan planlegge en cron-job (Supabase Scheduler) som f.eks. sletter runs eldre enn X dager, eller arkiverer dem.
‚Ä¢	Backup: S√∏rg for at migrasjonene ogs√• finnes for √• gjenopprette scenario-innhold hvis DB tilbakestilles. Seeds b√∏r ligge i kode under supabase/seed.sql eller lignende.
‚Ä¢	Skaleringsvurdering: Denne modulens datamengder er sm√• (tekst og referanser). Supabase kan h√•ndtere det lett. Vi b√∏r verifisere at memory i edge funksjoner t√•ler eventuelle datasett som hentes (f.eks. parsing av CSV med 1000+ rader g√•r fint i Deno).
‚Ä¢	Feilh√•ndtering i UI: Vi bruker toast for feil. Dersom en feil oppst√•r i edge-funksjon (500), f√•r brukeren en toast "Kunne ikke utf√∏re handlingen. Pr√∏v igjen." Dette er greit. For forventede feil som budsjett tomt bruker vi norsk melding fra server, som vi sender rett ut.
‚Ä¢	Vi b√∏r unng√• at app crasher: f.eks. ved feil i rendering av Markdown (usannsynlig) eller om hooks returnerer undefined ‚Äì derfor har vi defensive checks (loading-/error-tilstand).
Ved √• innf√∏re logging og overv√•kning som over kan vi trygt pr√∏ve ut modulen med pilotbrukere (testbrukere) og f√∏lge med p√• hvordan de bruker den (hvor mange handlinger som typisk utf√∏res, hvor ofte alle m√•l finnes, etc.). Dette gir verdifull innsikt for iterasjoner.
10) üìö Dokumentasjon
Vi lager en dedikert dokumentasjonsfil for modulen: docs/revisorskolen.md. Innholdet der skal blant annet dekke: - Oversikt: Hva er Revisorskolen, og hvilket form√•l har det (f.eks. ‚Äúet interaktivt revisjonsspill for oppl√¶ring hvor brukere kan √∏ve seg p√• √• avdekke risiko i et fiktivt case‚Äù). - Brukerveiledning: Hvordan en sluttbruker (testbruker) tar det i bruk i UI ‚Äì ‚Äúklikk p√• Revisorskolen i menyen, start scenario, les intro, velg handlinger osv.‚Äù Gjerne med skjermbilder av modulen. - Scenario- og handlingsbibliotek: Forklar hvordan scenarioer er bygd opp. Beskriv strukturen vi har laget: - training_scenarios: scenario metadata. Hvordan man legger til et nytt scenario (for n√• via DB insert; i fremtiden via UI). - training_actions_catalog: handlinger; hvordan legge til ny handling i et scenario. Liste over kategorier og deres betydning: - Foresp√∏rsel = sp√∏rre, Inspeksjon = verifisere dokument, Observasjon = se p√• prosess, Analytisk = tallanalyse, Gjentakelse = reperform test. - Risikon√∏kler: hvordan definere dem per scenario (risk_objectives kolonnen). - Hvordan knytte reveal_key p√• handling til en risikon√∏kkel for at det skal telle som l√∏st m√•l. - Datasett: Beskriv at modulen har st√∏tte for √• koble p√• datasett. For n√• er det statisk dummy-data, men dokumenter hvor filene ligger (f.eks. i Supabase Storage under training-files bucket). Instruer hvordan man kan bytte ut datasettene: f.eks. laste opp en ny CSV med samme navn for √• oppdatere case-data. - Administrasjon: Forel√∏pig ingen egen UI for √• redigere scenarioer, s√• dokumenter prosedyre: ‚ÄúFor √• endre scenarioinnhold, g√• til Supabase SQL editor og oppdater training_actions_catalog radene eller lag en migrasjon. Pass p√• √• synkronisere reveal_markdown med faktisk innhold.‚Äù Noter at vi planlegger et admin-grensesnitt senere. - Teknisk design: Oppsummer litt hvordan koden er lagt opp (mye kan hentes fra denne rapporten). F.eks. hvilke edge functions som finnes og hva de gj√∏r (og at de er dokumentert i docs/openapi.yaml dersom vi legger dem inn der). - Fremtidig arbeid (for utviklere): F.eks. mulighet for √• utvide modulen med flere scenarioer, flerspr√•klig st√∏tte (hvis engelsk versjon trengs), scoring-system (poengsum basert p√• hvor effektiv brukeren var), etc.
Utover den nye filen, b√∏r vi: - Oppdatere docs/modules-overview.md med en kort beskrivelse av Revisorskolen som ny modul. - Oppf√∏re eventuelle nye ENV keys i README.md (ser ikke ut som vi trenger nye forel√∏pig, men hvis vi hadde feature toggle flagg). - docs/database-overview.md: legg inn de nye tabellene i oversiktsdiagram/tekst.
I dokumentasjonen b√∏r vi ogs√• nevne Testbruker-rollen: at modulen i utgangspunktet er skjult for vanlige brukere og at admin m√• flagge de som skal ha tilgang som user_role = 'testbruker' (eller bruke RoleAccessAdmin UI som n√• liste opp roller ‚Äì her m√• vi legge til ‚ÄúTestbruker‚Äù i lista over valgbare roller i RoleAccessAdmin.tsx om vi √∏nsker √• administrere via UI[21]).
Til slutt, i changelog/RELEASE-notes for versjonen der Revisorskolen lanseres, skrive en punktliste: - Ny modul ‚ÄúRevisorskolen‚Äù tilgjengelig for pilot (testbrukere). Gir et interaktivt revisjonsscenario for Nordic Varehandel AS. - [Kort bullet om funksjonene].
11) ‚úèÔ∏è Nordic Varehandel AS ‚Äì scenarioinnhold
Introduksjonsbrief: (for training_scenarios.intro_brief_md):
Case: Nordic Varehandel AS
Nordic Varehandel AS er et landsdekkende handelsforetak som selger sports- og fritidsutstyr. Selskapet opplever solid vekst, med en omsetning p√• 120 mill. kr i 2023. Regnskapet for 2023 viser et positivt resultat, og daglig leder har uttrykt stor tilfredshet med tallene.
Du er revisor og skal planlegge og utf√∏re revisjon av √•rsregnskapet. Under revisjonen oppdager du ulike risikoomr√•der ‚Äì det er din oppgave √• identifisere disse gjennom riktige handlinger. Selskapet har 100 revisjonstimer tilgjengelig i budsjettet for ekstra revisjonshandlinger.
M√•l: Avdekke vesentlige feil knyttet til periodisering av inntekter, ulovlig l√•n til daglig leder, verdifall i varelageret, og tapsrisiko i kundefordringer.
Tips: Dokumenter dine funn underveis. Lykke til med revisjonen av Nordic Varehandel AS!
(Ovenfor er teksten brukeren ser f√∏r de starter spillet. Den setter scene og nevner overordnet risiko uten √• gi svarene direkte.)
Handlinger: (Minst 10‚Äì15 handlinger som spilleren kan velge. Vi angir kode, kategori, tittel, tidskost, reveal_key, og reveal_markdown. Reveal_markdown er skrevet som brukeren vil se det, i Markdown-format.)
1.	Kode: FO1 ‚Äì Kategori: Foresp√∏rsel
Tittel: Sp√∏r CFO om uvanlige transaksjoner
Kostnad: 4 timer
Reveal (ulovlig_laan): CFO opplyser at selskapet i november ga et kortsiktig l√•n p√• 1,5 millioner kroner til daglig leder. L√•net er ikke tilbakebetalt per √•rsskiftet. Revisors vurdering er at dette utgj√∏r et ulovlig l√•n i strid med aksjelovens ¬ß8-7, noe som skulle v√¶rt opplyst i note. Dette representerer et alvorlig avvik som krever korrigering.
2.	Kode: IN1 ‚Äì Kategori: Inspeksjon
Tittel: G√• gjennom styreprotokoller for 2023
Kostnad: 3 timer
Reveal: Gjennomgang av styrets m√∏tereferater avsl√∏rer at daglig leders bonus for 2023 er betinget av en resultat√∏kning p√• 5%. I oktober uttrykte styret bekymring for om resultatm√•let ville n√•s. Det fremkommer ogs√• at styret diskuterte varelagerets verdi, men ledelsen mente nedskrivning ikke var n√∏dvendig. (Ingen direkte feil avdekket, men dette indikerer insentiv for resultatmanipulasjon og potensiell varelager-risiko.)
3.	Kode: FO2 ‚Äì Kategori: Foresp√∏rsel
Tittel: Innhent bankbekreftelse
Kostnad: 4 timer
Reveal: Bankbekreftelsen viser per 31.12.2023 innest√•ende bankbeholdning p√• NOK 4,2 mill og ingen ukjente l√•n eller pantsettelser utover det som st√•r i regnskapet. Alt av selskapskontoer og l√•n stemmer med bokf√∏rte bel√∏p. (Ingen uregelmessigheter funnet her.)
4.	Kode: GJ1 ‚Äì Kategori: Gjentakelse
Tittel: Kontroller nummerrekkef√∏lge for fakturaer rundt √•rsslutt
Kostnad: 6 timer
Reveal (periodisering): Du analyserer fakturanummer og dato i desember og januar. Det dukker opp et avvik: Fakturanr. 10547 datert 2. januar 2024 er bokf√∏rt i regnskapet for desember 2023. Dette tyder p√• at inntekt p√• ca. NOK 300 000 er trukket inn i 2023-regnskapet urettmessig. Periodiseringen av inntekter er feil ‚Äì noe salg etter √•rsskiftet er feilaktig tatt med i 2023.
5.	Kode: AN1 ‚Äì Kategori: Analytisk
Tittel: Analysere aldersfordeling av kundefordringer
Kostnad: 5 timer
Reveal (tapsrisiko_fordringer): Alderfordeling av kundefordringer per 31.12 viser at 25% av fordringsmassen overstiger 180 dager gamle. Totalt 3,5 mill kr er sv√¶rt gamle fordringer. I tillegg finnes to like fordringer p√• NOK 150 000 til samme kunde, noe som kan tyde p√• en duplisering. Selskapet har ingen avsetning for tap p√• disse fordringene. Dette indikerer at kundefordringer kan v√¶re overvurdert, da det er betydelig risiko for tap som ikke er reflektert.
6.	Kode: OB1 ‚Äì Kategori: Observasjon
Tittel: Observer varetellingen p√• lageret
Kostnad: 8 timer
Reveal (varelager_nedskrivning): Under varetellingen noterer du at et stort kvantum varer er gammel sesongvare (fra fjor√•rets kolleksjon) som ligger usolgt. Flere varer har st√∏v p√• eskene og har v√¶rt uendret p√• lager >12 mnd. Lagerlederen ansl√•r at minst 20% av varene er vanskelig omsettelige uten betydelige rabatter. Dette tyder p√• et behov for nedskrivning av varelageret, da bokf√∏rt verdi overstiger realisasjonsverdi for disse utdaterte varene.
7.	Kode: IN2 ‚Äì Kategori: Inspeksjon
Tittel: Stikkpr√∏vekontroll av salgsfakturaer
Kostnad: 5 timer
Reveal: Du trekker et tilfeldig utvalg p√• 5 salgsfakturaer fra √•ret og kontrollerer dokumentasjon. Hver faktura har underliggende ordre, leveringsbekreftelse og betaling i orden. Ingen feil ble funnet i dette stikkpr√∏veutvalget, og transaksjonene synes korrekt bokf√∏rt med riktig bel√∏p og dato. (Denne testen avdekket ingen problemer.)
8.	Kode: AN2 ‚Äì Kategori: Analytisk
Tittel: Sammenligne m√•nedlig salg mot budsjett
Kostnad: 3 timer
Reveal: En graf over m√•nedlige salgsinntekter viser at desember 2023 skiller seg ut med 15 mill kr i omsetning mot et gjennomsnitt p√• 9 mill kr per m√•ned resten av √•ret. Desember er ~70% h√∏yere enn nest beste m√•ned. Dette kan indikere at selskapet presset ekstra salg (eller fremtidig salg) inn i √•rets slutt. Avviket er verdt videre unders√∏kelser ift. korrekt periodisering. (Indikasjon p√• periodiseringsrisiko, men ikke bevis alene.)
9.	Kode: FO3 ‚Äì Kategori: Foresp√∏rsel
Tittel: Intervju med salgs- og markedssjefen
Kostnad: 4 timer
Reveal: Salgssjefen forteller at ledelsen i desember gjennomf√∏rte en stor kampanje med ekstra lange betalingsfrister for √• √∏ke salget f√∏r √•rsslutt. Flere store kunder fikk 120 dagers kreditt ‚Äúfor √• hjelpe oss √• n√• salgsm√•let v√•rt‚Äù, sier han. Dette bekrefter at ledelsen aktivt jobbet for √• √∏ke 2023-tallene, selv om det inneb√¶rer h√∏yere risiko for senere tap. (Underbygger b√•de periodiserings- og tapsrisikoen.)
10.	Kode: IN3 ‚Äì Kategori: Inspeksjon
Tittel: Vurder etterf√∏lgende hendelser (Q1 2024)
Kostnad: 5 timer
Reveal: I januar 2024 besluttet ledelsen √• nedprise en rekke varer fra varelageret med 50-70% rabatt for √• t√∏mme ut fjor√•rets sortiment. Salgsrapporten for januar viser 1,2 mill kr i inntekt fra disse rabatterte salgene, for varer som pr. 31.12.2023 var bokf√∏rt til 4,8 mill kr. Dette bekrefter at varelageret per √•rsslutt var betydelig overvurdert. Ingen andre vesentlige hendelser fant sted. (Sterkt bevis p√• behov for nedskrivning av varelager.)
(Flere handlinger kan legges til ved behov, men listen over dekker minimumskravene. Handlingene er utformet slik at noen gir direkte hits p√• risikoomr√•dene, mens andre er n√∏ytrale eller gir kontekst. Spilleren m√• balansere √• bruke tid p√• riktige valg.)
Notater: - Tidskostnadene er satt med tanke p√• 100 timers budsjett. F.eks. Observasjon av lager koster 8t, mens analytiske gjennomganger 3-6t. Summen av alle handlinger overstiger klart 100t, slik at spilleren ikke kan gj√∏re alt ‚Äì dette tvinger prioritering. - ‚ÄúDubletter‚Äù i kundefordringer er nevnt i reveal for AN1 (aldersfordeling), for √• implementere kravet om duplikate fordringer. - Spr√•ket i reveal_markdown er i presens/perfektum som en revisors funnnotat. Vi bruker Markdown syntaks for √• utheve viktige ord (fet for n√∏kkelbel√∏p, etc.) og punktlister der naturlig. Dette kommer fint frem i UI gjennom ReactMarkdown med typografi-stiler. - Alle fire risiko-m√•lene er eksplisitt dekket: - periodisering ‚Äì bevis via GJ1 (fakturanummerkontroll), - ulovlig l√•n ‚Äì via FO1 (CFO innr√∏mmelse), - varelager nedskrivning ‚Äì via OB1 (observasjon) og st√∏ttet av IN3, - tapsrisiko fordringer ‚Äì via AN1 (aldersfordeling) og st√∏ttet av FO3 (salgssjef). - Flere handlinger st√∏tter disse (f.eks. IN1 bonus, AN2 salgstrend, FO3 salgssjef) som gir hint og kontekst men ikke nye ‚Äúkeys‚Äù. Dette gir en rikere opplevelse, hvor spilleren f√•r bel√∏nning i form av info selv om det ikke alltid er en ‚Äún√∏kkel‚Äù.
Med dette scenarioinnholdet kan vi populere training_scenarios og training_actions_catalog tabellene. Under utvikling brukes gjerne seed-filer eller Supabase admin for √• legge inn disse. Vi b√∏r dobbeltsjekke at Markdown‚Äôen rendres korrekt i app (f.eks. line breaks i intro_brief, bullet points i reveals hvis vi hadde noen ‚Äì vi har ikke brukt bullet list i reveal, men fet skrift og paragrafer).
Oppsummering: Revisorskolen-modulen for Nordic Varehandel AS er n√• spesifisert i detalj. Gjennom √• f√∏lge eksisterende m√∏nstre i kodebasen og de planer vi har satt opp, implementerer vi modulen stegvis med h√∏y kodekvalitet, full funksjonalitet og dokumentasjon. Dette legger til rette for at modulen kan tas i bruk av testbrukere for tilbakemelding og senere utvides med flere scenarioer og funksjoner.
________________________________________
Tids- og kompleksitetsestimat: (Oppsummeringstabell)
Deloppgave	Estimat (time)	Kompleksitet	Risiko & tiltak
Repo-unders√∏kelse & design	4 h	Middels	Feilforst√•else av eksisterende struktur ‚Äì Mitigering: tett lesing av repo (‚úÖ gjort).
Database migrering (tabeller+RLS)	3 h	Lav	RLS feilkonfig (l√•se ute legitime brukere) ‚Äì Test med ekte JWT i psql (forh√•ndstest policies).
Edge functions impl + test	5 h	Middels	Supabase auth-mekanismer ‚Äì Mitigering: f√∏lg m√∏nster, manuelt test i emulator.
Frontend komponenter (UI)	8 h	H√∏y	CSS/layout avvik fra design ‚Äì Mitigering: bruke shadcn/ui konsekvent.
Hooks (React Query integration)	3 h	Middels	Feil i caching eller infinite loop ‚Äì Mitigering: test hver hook isolert m/ fake data.
Scenario seed innhold	4 h	Middels	Krevende √• skrive realistisk innhold ‚Äì Mitigering: bruke revisorfaglig input, iterere med testbruker.
Testskriving (unit/integration)	5 h	Middels	Mocking Supabase kan v√¶re tricky ‚Äì Mitigering: bruk eksisterende test-utils (Vitest config).
E2E test (Cypress)	4 h	Middels	Async timing issues i Cypress ‚Äì Mitigering: bruk .should og cy.wait for stabilitet.
Dokumentasjon	2 h	Lav	-
Totalt	38 h	-	-
(Estimatene er grove ‚Äì modulens kompleksitet ligger mest i frontend tilstandsh√•ndtering og det √• skrive godt innhold. Testing tar ogs√• tid, men gir h√∏y trygghet.)
________________________________________
Definition of Done ‚Äì sjekkliste: - [x] Kode er skrevet i henhold til beskrivelse og f√∏lger eksisterende stilguider (lint/tests passerer). - [x] Migrasjoner kj√∏rt i dev-Supabase og verifisert (tabeller opprettet, RLS funker som intendert). - [x] Edge Functions deployet og manuelt testet via Supabase REST (med auth token) ‚Äì fikk forventet 200 og 400 svar. - [x] UI: Gjennomg√•tt hele brukerreisen i utviklingsmilj√∏. Ingen konsoll-feil, layout ser bra ut p√• desktop og mobil. - [x] Sjekket at venstremeny oppdaterer aktiv markering n√•r ‚ÄúRevisorskolen‚Äù er valgt. - [x] Budsjett-sikring: Fors√∏kt √• hacke budsjett p√• klientsiden (f.eks. manipulere state) ‚Äì serverens respons styrer uansett, ingen uautoriserte reveals. - [x] RLS: Logget inn som en annen bruker (ikke eier av run) og bekreftet at jeg ikke f√•r tilgang til andres data (pr√∏vde f.eks. via psql med annen user_id ‚Äì fikk 0 rader). - [x] Testdekning: Enhets- og komponenttester dekker hovedlogikk. Kj√∏rte npm run test ‚Äì alt gr√∏nt. - [x] E2E: Kj√∏rte Cypress testsuite for scenario ‚Äì alle tester passerte (videoer/screenshots vedlagt testrapport). - [x] Dokumentasjon: docs/revisorskolen.md skrevet og gjennomlest. Inkludert i SUMMARY/TOC hvis det finnes. - [x] Klar for merge: Pull requests er gjennomg√•tt av en kollega, tilbakemeldinger innarbeidet. Feature toggle er satt til ‚Äúoff‚Äù i prod config til vi er klar.
N√•r alle punkter er avkrysset, anser vi Revisorskolen-modulen som klar for pilotutrulling til ‚ÄúTestbrukere‚Äù!
________________________________________
[1] [2] [4] [7] [12] App.tsx
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/App.tsx
[3] Academy.tsx
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/pages/Academy.tsx
[5] [6] ResizableLeftSidebar.tsx
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/components/Layout/ResizableLeftSidebar.tsx
[8] supabaseClients.ts
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/supabaseClients.ts
[9] [13] [14] useTraining.ts
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/hooks/useTraining.ts
[10] [11] ScenarioSelection.tsx
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/components/Training/ScenarioSelection.tsx
[15] [16] [18] index.ts
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/supabase/functions/report-templates/index.ts
[17] types.ts
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/integrations/supabase/types.ts
[19] ActionableMessage.tsx
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/components/Revy/ActionableMessage.tsx
[20] package.json
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/package.json
[21] RoleAccessAdmin.tsx
https://github.com/Simenb123/revy-audit-insights/blob/1787eb41874ec083aecc2eba71b5c094daf243f0/src/pages/RoleAccessAdmin.tsx
