import { RevyContext, RevyMessage } from '@/types/revio';
import { supabase } from '@/integrations/supabase/client';
import { searchRelevantKnowledge, RelevantKnowledge } from './knowledgeIntegrationService';
import { analyzeAuditProcess, generateContextualRecommendations, getPhaseGuidance } from './revyAuditProcessService';

// Context-aware tips for Revy assistant (fallback hvis AI feiler)
const contextualTips: Record<string, string[]> = {
  'dashboard': [
    'Velkommen til dashbordet! Her ser du en oversikt over n√∏kkeltall for klienten.',
    'Klikk p√• en regnskapslinje i oversikten for √• se detaljene.',
    'Ser du de r√∏de indikatorene? Det kan tyde p√• h√∏yrisiko-omr√•der som krever oppmerksomhet.',
    'Husker du √• sjekke endringen fra forrige periode? Store svingninger kan v√¶re risikoindikatorer.'
  ],
  'client-overview': [
    'Her ser du alle klientene du er ansvarlig for.',
    'Klikk p√• en klient for √• se detaljer og revisjonsstatus.',
    'Legg merke til varslene som indikerer kritiske datoer eller manglende dokumentasjon.',
    'Bruk filterfunksjonen for √• sortere klienter etter bransje eller revisjonsfase.'
  ],
  'collaboration': [
    'Samarbeidsverkt√∏yene hjelper deg √• koordinere med teamet ditt.',
    'Bruk arbeidsomr√•der for √• organisere dokumenter og diskusjoner per klient.',
    'Videom√∏ter og chat gj√∏r det enkelt √• holde kontakt med kolleger.',
    'Husk √• dokumentere viktige beslutninger fra teamm√∏ter.'
  ],
  'general': [
    'Jeg er Revy, din revisjonsassistent! Sp√∏r meg om hjelp n√•r som helst.',
    'Trenger du hjelp med noe spesifikt? Jeg kan veilede deg gjennom revisjonsprosessen.',
    'Tips: Bruk s√∏kefunksjonen √∏verst for √• finne dokumenter eller revisjonssteg.',
    'Husk √• lagre arbeidet ditt regelmessig!'
  ]
};

// Get contextual tip based on current context (fallback)
export const getContextualTip = (context: RevyContext): string => {
  const tips = contextualTips[context as string] || contextualTips['general'];
  return tips[Math.floor(Math.random() * tips.length)];
};

// Enhanced AI-powered response generation with knowledge integration
export const generateAIResponse = async (
  message: string, 
  context: string = 'general',
  clientData?: any,
  userRole: string = 'employee',
  sessionId?: string
): Promise<string> => {
  try {
    console.log('üîç Generating enhanced AI response with knowledge integration', { 
      context, 
      hasClientData: !!clientData, 
      userRole,
      messageLength: message.length 
    });

    // Search relevant knowledge base content
    const relevantKnowledge = await searchRelevantKnowledge(
      message, 
      context, 
      clientData?.subject_area,
      clientData?.phase
    );

    // Analyze audit process if client data is available
    let auditInsights = null;
    if (clientData && clientData.id) {
      auditInsights = await analyzeAuditProcess(clientData, userRole);
    }

    // Get phase-specific guidance
    let phaseGuidance = null;
    if (clientData?.phase) {
      phaseGuidance = await getPhaseGuidance(clientData.phase, clientData.industry);
    }

    // Generate contextual recommendations
    let recommendations: string[] = [];
    if (clientData) {
      recommendations = await generateContextualRecommendations(
        message, 
        clientData, 
        clientData.phase || 'planning', 
        userRole
      );
    }

    // Build enhanced prompt with knowledge integration
    const knowledgeContext = buildKnowledgeContext(relevantKnowledge, auditInsights, phaseGuidance);
    
    const enhancedMessage = `
${message}

CONTEXT: ${context} ${clientData ? `- Klient: ${clientData.company_name || clientData.name}` : ''}
${clientData?.phase ? `REVISJONSFASE: ${clientData.phase}` : ''}
${clientData?.industry ? `BRANSJE: ${clientData.industry}` : ''}
ROLLE: ${userRole}

${knowledgeContext}

INSTRUKSJONER:
1. Svar direkte og praktisk p√• sp√∏rsm√•let
2. Referer til relevante fagartikler og ISA-standarder n√•r aktuelt
3. Gi konkrete neste steg basert p√• revisjonsfasen
4. Inkluder bransje-spesifikke r√•d hvis relevant
5. Foresl√• spesifikke handlinger eller prosedyrer
6. Vurder risikoaspekter og kvalitetskrav
7. Tilpass svaret til brukerens rolle og erfaring

Gj√∏r svaret handlingsrettet med konkrete forslag og faglige referanser.`;

    const { data, error } = await supabase.functions.invoke('revy-ai-chat', {
      body: {
        message: enhancedMessage,
        context,
        clientData,
        userRole,
        userId: supabase.auth.getUser().then(u => u.data.user?.id),
        sessionId,
        knowledgeContext: relevantKnowledge,
        auditInsights,
        recommendations
      }
    });

    if (error) {
      console.error('‚ùå Supabase function error:', error);
      throw new Error(error.message || 'Failed to get AI response');
    }

    if (data.isError) {
      console.warn('‚ö†Ô∏è AI function returned error response');
      return data.response || 'Beklager, jeg kunne ikke behandle foresp√∏rselen din akkurat n√•.';
    }

    console.log('‚úÖ Enhanced AI response with knowledge integration received', { 
      responseLength: data.response?.length,
      model: data.model,
      usage: data.usage,
      knowledgeArticles: relevantKnowledge?.articles?.length || 0,
      isaStandards: relevantKnowledge?.isaStandards?.length || 0
    });

    // Enhance response with knowledge references
    const enhancedResponse = enhanceResponseWithKnowledge(data.response, relevantKnowledge, recommendations);

    return enhancedResponse || 'Jeg kunne ikke generere et svar akkurat n√•. Pr√∏v igjen senere.';

  } catch (error) {
    console.error('üí• Error in generateAIResponse:', error);
    
    // Enhanced fallback with knowledge integration
    const contextualFallback = await getEnhancedContextualFallback(context, clientData, userRole, message);
    return contextualFallback;
  }
};

// Build knowledge context for AI prompt
const buildKnowledgeContext = (
  knowledge: RelevantKnowledge | null,
  auditInsights: any,
  phaseGuidance: any
): string => {
  let context = '\nTILGJENGELIG KUNNSKAP:\n';
  
  if (knowledge?.articles && knowledge.articles.length > 0) {
    context += '\nRelevante fagartikler:\n';
    knowledge.articles.slice(0, 3).forEach((result, index) => {
      context += `${index + 1}. "${result.article.title}": ${result.article.summary || 'Ingen sammendrag'}\n`;
    });
  }
  
  if (knowledge?.isaStandards && knowledge.isaStandards.length > 0) {
    context += `\nRelevante ISA-standarder: ${knowledge.isaStandards.join(', ')}\n`;
  }
  
  if (knowledge?.procedures && knowledge.procedures.length > 0) {
    context += '\nForesl√•tte prosedyrer:\n';
    knowledge.procedures.slice(0, 3).forEach((proc, index) => {
      context += `- ${proc}\n`;
    });
  }
  
  if (auditInsights) {
    context += `\nREVISJONSSTATUS:\n`;
    context += `- Gjeldende fase: ${auditInsights.currentPhase}\n`;
    context += `- Fremdrift: ${auditInsights.completionRate}%\n`;
    if (auditInsights.riskAreas.length > 0) {
      context += `- Risikoomr√•der: ${auditInsights.riskAreas.join(', ')}\n`;
    }
  }
  
  if (phaseGuidance) {
    context += `\nFASEVEILEDNING (${phaseGuidance.phaseDescription}):\n`;
    context += `Hovedm√•l: ${phaseGuidance.keyObjectives.slice(0, 2).join(', ')}\n`;
  }
  
  return context;
};

// Enhance AI response with knowledge references and links
const enhanceResponseWithKnowledge = (
  response: string,
  knowledge: RelevantKnowledge | null,
  recommendations: string[]
): string => {
  let enhancedResponse = response;
  
  // Add knowledge references
  if (knowledge?.articles && knowledge.articles.length > 0) {
    enhancedResponse += '\n\nüìö **Relevante ressurser:**\n';
    knowledge.articles.slice(0, 2).forEach(result => {
      enhancedResponse += `‚Ä¢ ${result.article.title}\n`;
    });
  }
  
  // Add ISA references
  if (knowledge?.isaStandards && knowledge.isaStandards.length > 0) {
    enhancedResponse += `\nüìã **ISA-standarder:** ${knowledge.isaStandards.slice(0, 3).join(', ')}\n`;
  }
  
  // Add recommendations
  if (recommendations.length > 0) {
    enhancedResponse += '\nüí° **Anbefalinger:**\n';
    recommendations.slice(0, 3).forEach(rec => {
      enhancedResponse += `‚Ä¢ ${rec}\n`;
    });
  }
  
  return enhancedResponse;
};

// Enhanced contextual fallback with knowledge integration
const getEnhancedContextualFallback = async (
  context: string, 
  clientData?: any, 
  userRole: string = 'employee',
  originalQuery: string = ''
): Promise<string> => {
  try {
    // Try to get some knowledge even in fallback mode
    const knowledge = await searchRelevantKnowledge(originalQuery, context);
    
    let fallback = getContextualFallback(context, clientData, userRole);
    
    // Add knowledge-based suggestions to fallback
    if (knowledge?.articles && knowledge.articles.length > 0) {
      fallback += '\n\nBasert p√• fagstoffet kan du:';
      knowledge.articles.slice(0, 2).forEach(result => {
        fallback += `\n‚Ä¢ Les "${result.article.title}" for mer informasjon`;
      });
    }
    
    if (knowledge?.procedures && knowledge.procedures.length > 0) {
      fallback += '\n\nRelevante prosedyrer:';
      knowledge.procedures.slice(0, 2).forEach(proc => {
        fallback += `\n‚Ä¢ ${proc}`;
      });
    }
    
    return fallback;
  } catch (error) {
    console.error('Error in enhanced fallback:', error);
    return getContextualFallback(context, clientData, userRole);
  }
};

// Enhanced contextual fallback function
const getContextualFallback = (context: string, clientData?: any, userRole: string = 'employee'): string => {
  const fallbacks = {
    'risk-assessment': `Jeg har tekniske problemer, men her er noen tips for risikovurdering:
    
‚Ä¢ Start med √• identifisere ${clientData?.industry ? `${clientData.industry}-spesifikke` : 'bransje'} risikoer
‚Ä¢ Vurder materialitetsniv√• basert p√• ${clientData?.company_name ? `${clientData.company_name}s` : 'klientens'} st√∏rrelse  
‚Ä¢ Se ISA 315 for detaljerte retningslinjer om risikoidentifisering
‚Ä¢ Dokumenter alle vesentlige risikovurderinger

Du kan g√• til Risikoanalyse-seksjonen for √• starte en strukturert gjennomgang.`,

    'client-detail': `Midlertidig feil. For ${clientData?.company_name || 'klientanalyse'}:
    
‚Ä¢ Analyser n√∏kkeltall som omsetningsvekst og l√∏nnsomhet
‚Ä¢ Sammenlign med bransjegjennomsnitt ${clientData?.industry ? `(${clientData.industry})` : ''}
‚Ä¢ Vurder trender over tid og sesongvariasjoner
‚Ä¢ Identifiser avvik som krever oppf√∏lging

G√• til klientdetaljene for fullstendig analyse og fremdriftsoppf√∏lging.`,

    'documentation': `Tekniske problemer oppst√•tt. For dokumentasjon:
    
‚Ä¢ ISA 230 krever tilstrekkelig og hensiktsmessig dokumentasjon
‚Ä¢ Strukturer arbeidspapirene logisk med klar konklusjon
‚Ä¢ Inkluder alle vesentlige vurderinger og beslutninger
‚Ä¢ Forbered for partner review og kvalitetskontroll

Bruk Dokumentasjon-seksjonen for standardiserte maler og sjekklister.`,

    'general': `Jeg opplever tekniske problemer akkurat n√•. 
    
Mens jeg er utilgjengelig, kan du:
‚Ä¢ Utforske kunnskapsbasen for faglige sp√∏rsm√•l
‚Ä¢ Sjekke fremdrift p√• p√•g√•ende revisjoner
‚Ä¢ Laste opp dokumenter eller regnskapsdata
‚Ä¢ Kontakte teamleder hvis det haster

Pr√∏v igjen om litt, eller kontakt support hvis problemet vedvarer.`
  };

  const roleSpecific = userRole === 'partner' ? 
    '\n\nSom partner: Vurder ogs√• portef√∏ljens samlede risiko og strategiske implikasjoner.' :
    userRole === 'manager' ? 
    '\n\nSom manager: S√∏rg for at teamet f√∏lger prosedyrer og kvalitetsstandarder.' :
    '\n\nKontakt din manager for ytterligere veiledning ved behov.';
  
  return (fallbacks[context as keyof typeof fallbacks] || fallbacks.general) + roleSpecific;
};

// Local fallback for when AI service is unavailable
const getLocalFallbackResponse = (context: string, userRole?: string): string => {
  const fallbacks = {
    'risk-assessment': 'Jeg har tekniske problemer, men her er noen generelle tips for risikovurdering: Start med √• identifisere klientens bransje og n√∏kkelrisikoer. Vurder materialitetsniv√• basert p√• st√∏rrelse og kompleksitet. Se ISA 315 for detaljerte retningslinjer.',
    'documentation': 'Tekniske problemer oppst√•tt. For dokumentasjon, husk: ISA 230 krever at all dokumentasjon skal v√¶re tilstrekkelig og hensiktsmessig for √• st√∏tte revisjonskonklusjoner. Strukturer arbeidspapirene logisk og inkluder alle vesentlige vurderinger.',
    'client-detail': 'Midlertidig feil. For klientanalyse, se p√• n√∏kkeltall som omsetningsvekst, l√∏nnsomhet og likviditet. Sammenlign med bransjegjennomsnitt og vurder trender over tid.',
    'collaboration': 'Teknisk feil. For teamarbeid: S√∏rg for klar rollefordeling, regelmessig kommunikasjon og dokumenterte beslutninger. Bruk standardiserte maler for konsistens.',
    'general': 'Jeg opplever tekniske problemer, men jeg er her for √• hjelpe! Pr√∏v igjen om litt, eller still sp√∏rsm√•l om revisjonsarbeid s√• skal jeg gj√∏re mitt beste for √• hjelpe deg.'
  };
  
  const roleSpecific = userRole === 'partner' ? 
    ' Som partner b√∏r du ogs√• vurdere klientportef√∏ljens samlede risiko og strategiske implikasjoner.' :
    userRole === 'manager' ? 
    ' Som manager, s√∏rg for at teamet f√∏lger etablerte prosedyrer og kvalitetsstandarder.' :
    ' Kontakt din manager hvis du trenger ytterligere veiledning eller st√∏tte.';
  
  return (fallbacks[context as keyof typeof fallbacks] || fallbacks.general) + roleSpecific;
};

// Legacy function for backwards compatibility
export const generateResponse = (userMessage: string, context: RevyContext): string => {
  return getContextualTip(context);
};

// New function to fetch AI usage statistics
export const getAIUsageStats = async (timeframe: 'day' | 'week' | 'month' = 'week') => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session?.user?.id) {
      console.log('No authenticated user for AI usage stats');
      // Return empty stats instead of throwing error
      return {
        logs: [],
        summary: {
          totalRequests: 0,
          totalTokens: 0,
          totalCost: 0,
          avgResponseTime: 0,
          modelUsage: {},
          contextUsage: {}
        }
      };
    }

    let dateFilter = new Date();
    switch (timeframe) {
      case 'day':
        dateFilter.setDate(dateFilter.getDate() - 1);
        break;
      case 'week':
        dateFilter.setDate(dateFilter.getDate() - 7);
        break;
      case 'month':
        dateFilter.setMonth(dateFilter.getMonth() - 1);
        break;
    }

    const { data, error } = await supabase
      .from('ai_usage_logs')
      .select(`
        id,
        user_id,
        model,
        prompt_tokens,
        completion_tokens,
        total_tokens,
        estimated_cost_usd,
        request_type,
        context_type,
        response_time_ms,
        created_at
      `)
      .eq('user_id', session?.user?.id)
      .gte('created_at', dateFilter.toISOString())
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching AI usage stats:', error);
      return null;
    }

    // Calculate summary statistics
    const summary = {
      totalRequests: data.length,
      totalTokens: data.reduce((sum, log) => sum + log.total_tokens, 0),
      totalCost: data.reduce((sum, log) => sum + Number(log.estimated_cost_usd), 0),
      avgResponseTime: data.length > 0 
        ? data.reduce((sum, log) => sum + (log.response_time_ms || 0), 0) / data.length 
        : 0,
      modelUsage: data.reduce((acc, log) => {
        acc[log.model] = (acc[log.model] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      contextUsage: data.reduce((acc, log) => {
        acc[log.context_type || 'unknown'] = (acc[log.context_type || 'unknown'] || 0) + 1;
        return acc;
      }, {} as Record<string, number>)
    };

    return {
      logs: data,
      summary
    };
  } catch (error) {
    console.error('Error in getAIUsageStats:', error);
    // Return empty stats on error
    return {
      logs: [],
      summary: {
        totalRequests: 0,
        totalTokens: 0,
        totalCost: 0,
        avgResponseTime: 0,
        modelUsage: {},
        contextUsage: {}
      }
    };
  }
};

// Function to get firm-wide usage stats (for admins)
export const getFirmAIUsageStats = async (timeframe: 'day' | 'week' | 'month' = 'week') => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session?.user?.id) {
      console.log('No authenticated user for AI usage stats');
      // Return empty stats instead of throwing error
      return {
        logs: [],
        summary: {
          totalRequests: 0,
          totalTokens: 0,
          totalCost: 0,
          avgResponseTime: 0,
          modelUsage: {},
          contextUsage: {}
        }
      };
    }

    let dateFilter = new Date();
    switch (timeframe) {
      case 'day':
        dateFilter.setDate(dateFilter.getDate() - 1);
        break;
      case 'week':
        dateFilter.setDate(dateFilter.getDate() - 7);
        break;
      case 'month':
        dateFilter.setMonth(dateFilter.getMonth() - 1);
        break;
    }

    const { data, error } = await supabase
      .from('ai_usage_logs')
      .select(`
        id,
        user_id,
        model,
        total_tokens,
        estimated_cost_usd,
        request_type,
        context_type,
        response_time_ms,
        created_at,
        profiles!inner(first_name, last_name, user_role)
      `)
      .gte('created_at', dateFilter.toISOString())
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching firm AI usage stats:', error);
      return null;
    }

    return data;
  } catch (error) {
    console.error('Error in getFirmAIUsageStats:', error);
    return null;
  }
};
